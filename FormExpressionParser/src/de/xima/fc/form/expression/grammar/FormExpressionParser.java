/* Generated By:JJTree&JavaCC: Do not edit this line. FormExpressionParser.java */
package de.xima.fc.form.expression.grammar;
import java.lang.StringBuilder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import de.xima.fc.form.expression.impl.variable.ELangObjectClass;
import de.xima.fc.form.expression.impl.variable.VoidClass;
import de.xima.fc.form.expression.enums.EMethod;
import de.xima.fc.form.expression.enums.ELogLevel;
import de.xima.fc.form.expression.enums.EVariableTypeFlag;
import de.xima.fc.form.expression.iface.parse.IComment;
import de.xima.fc.form.expression.grammar.comment.CommentFactory;
import de.xima.fc.form.expression.util.CmnCnst;
import de.xima.fc.form.expression.util.NullUtil;
import de.xima.fc.form.expression.node.*;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import com.google.common.collect.ImmutableList;

@SuppressWarnings("all")
public class FormExpressionParser/*@bgen(jjtree)*/implements FormExpressionParserTreeConstants, FormExpressionParserConstants {/*@bgen(jjtree)*/
  protected JJTFormExpressionParserState jjtree = new JJTFormExpressionParserState();private boolean _customLosAllowed = false;
  /** A list of all the comments occurring in the program. */
  @Nonnull private ImmutableList.Builder<IComment> _comments = new ImmutableList.Builder<IComment>();
  /** Current embedment context, or null when not in template mode. */
  @Nullable private String _currentEmbedmentContext;
  void setCurrentEmbedmentContext(String currentEmbedmentContext) {
    this._currentEmbedmentContext = currentEmbedmentContext;
  }
  void addComment(@Nonnull Token commentToken) {
    _comments.add(CommentFactory.fromToken(commentToken));
  }
  @Nullable public String getCurrentEmbedmentContext() {
    return _currentEmbedmentContext;
  }
  public void setLosAllowed(boolean losAllowed) {
    this._customLosAllowed = losAllowed;
  }
  @Nonnull public ImmutableList<IComment> buildComments() {
    return _comments.build();
  }

  final public Node Template(EMethod method) throws ParseException {
 /*@bgen(jjtree) StatementListNode */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LosChar:
        LosChars(null);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LosOpen:
          LosOpen(null);
          TemplateProgram(null);
          break;
        default:
          jj_la1[0] = jj_gen;
          ;
        }
        break;
      case LosOpen:
        LosOpen(null);
        TemplateProgram(null);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(0);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (token_source.curLexState == FormExpressionParserConstants.CODE)
      {if (true) throw new ParseException(CmnCnst.Error.FINAL_CODE_BLOCK_NOT_CLOSED, token);}
    jjtn000.init(method);

    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

/* Los = Literal Output Statement */
  final public void LosChars(EMethod method) throws ParseException {
 /*@bgen(jjtree) LosNode */
  ASTLosNode jjtn000 = new ASTLosNode(this, JJTLOSNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
  final StringBuilder sb = new StringBuilder();
    try {
      label_1:
      while (true) {
        t = jj_consume_token(LosChar);
        sb.append(t.getNonnullImage().charAt(0));
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LosChar:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_1;
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, sb.toString(), null, false);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void LosOpen(EMethod method) throws ParseException {
 /*@bgen(jjtree) LosNode */
  ASTLosNode jjtn000 = new ASTLosNode(this, JJTLOSNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(LosOpen);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (!_customLosAllowed) {if (true) throw new ParseException(
      NullUtil.messageFormat(CmnCnst.Error.EMBEDDED_BLOCK_NOT_ALLOWED), token);}
    jjtn000.init(method, CmnCnst.NonnullConstant.STRING_EMPTY, t.getNonnullImage(), false);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void LosBody(EMethod method) throws ParseException {
 /*@bgen(jjtree) LosNode */
  ASTLosNode jjtn000 = new ASTLosNode(this, JJTLOSNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t = null;
  Token p = null;
  final StringBuilder sb = new StringBuilder();
    try {
      jj_consume_token(LosBodyClose);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LosChar:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        t = jj_consume_token(LosChar);
        sb.append(t.getNonnullImage().charAt(0));
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LosOpen:
        p = jj_consume_token(LosOpen);
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (!_customLosAllowed) {if (true) throw new ParseException(
      NullUtil.messageFormat(CmnCnst.Error.EMBEDDED_BLOCK_NOT_ALLOWED), token);}
    jjtn000.init(method, sb.toString(), p != null ? p.image : null, true);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public Node CompleteProgram(EMethod method) throws ParseException {
 /*@bgen(jjtree) StatementListNode */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TypeHash:
      case TypeVar:
      case TypeError:
      case TypeRegex:
      case TypeArray:
      case TypeMethod:
      case TypeString:
      case TypeNumber:
      case TypeBoolean:
      case Plus:
      case Dash:
      case Tilde:
      case ParenOpen:
      case BracesOpen:
      case BracketOpen:
      case SemiColon:
      case Exclamation:
      case TemplateLiteralOpen:
      case DoublePlus:
      case DoubleDash:
      case If:
      case Do:
      case For:
      case Try:
      case Var:
      case With:
      case True:
      case Hash:
      case Null:
      case Break:
      case While:
      case Throw:
      case Array:
      case __Error:
      case Scope:
      case False:
      case Regex:
      case Number:
      case Return:
      case Method:
      case Switch:
      case Global:
      case String:
      case Boolean:
      case Require:
      case LogInfo:
      case LogWarn:
      case Continue:
      case Function:
      case LogError:
      case LogDebug:
      case __Exception:
      case Identifier:
      case Integer:
      case Float:
      case DoubleQuotedString:
      case SingleQuotedString:
      case BackslashQuotedRegex:
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TypeHash:
          case TypeVar:
          case TypeError:
          case TypeRegex:
          case TypeArray:
          case TypeMethod:
          case TypeString:
          case TypeNumber:
          case TypeBoolean:
          case Plus:
          case Dash:
          case Tilde:
          case ParenOpen:
          case BracesOpen:
          case BracketOpen:
          case SemiColon:
          case Exclamation:
          case TemplateLiteralOpen:
          case DoublePlus:
          case DoubleDash:
          case If:
          case Do:
          case For:
          case Try:
          case Var:
          case With:
          case True:
          case Hash:
          case Null:
          case Break:
          case While:
          case Throw:
          case Array:
          case __Error:
          case False:
          case Regex:
          case Number:
          case Return:
          case Method:
          case Switch:
          case String:
          case Boolean:
          case LogInfo:
          case LogWarn:
          case Continue:
          case LogError:
          case LogDebug:
          case __Exception:
          case Identifier:
          case Integer:
          case Float:
          case DoubleQuotedString:
          case SingleQuotedString:
          case BackslashQuotedRegex:
            ClauseOrStatement(null);
            break;
          case Scope:
          case Global:
          case Require:
            ScopeDefinition(null);
            break;
          case Function:
            FunctionClauseWithOptionalScope(null);
            break;
          default:
            jj_la1[5] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TypeHash:
          case TypeVar:
          case TypeError:
          case TypeRegex:
          case TypeArray:
          case TypeMethod:
          case TypeString:
          case TypeNumber:
          case TypeBoolean:
          case Plus:
          case Dash:
          case Tilde:
          case ParenOpen:
          case BracesOpen:
          case BracketOpen:
          case SemiColon:
          case Exclamation:
          case TemplateLiteralOpen:
          case DoublePlus:
          case DoubleDash:
          case If:
          case Do:
          case For:
          case Try:
          case Var:
          case With:
          case True:
          case Hash:
          case Null:
          case Break:
          case While:
          case Throw:
          case Array:
          case __Error:
          case Scope:
          case False:
          case Regex:
          case Number:
          case Return:
          case Method:
          case Switch:
          case Global:
          case String:
          case Boolean:
          case Require:
          case LogInfo:
          case LogWarn:
          case Continue:
          case Function:
          case LogError:
          case LogDebug:
          case __Exception:
          case Identifier:
          case Integer:
          case Float:
          case DoubleQuotedString:
          case SingleQuotedString:
          case BackslashQuotedRegex:
            ;
            break;
          default:
            jj_la1[6] = jj_gen;
            break label_3;
          }
        }
        jj_consume_token(0);
        break;
      case 0:
        jj_consume_token(0);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);

    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void TemplateProgram(EMethod method) throws ParseException {
 /*@bgen(jjtree) StatementListNode */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TypeHash:
        case TypeVar:
        case TypeError:
        case TypeRegex:
        case TypeArray:
        case TypeMethod:
        case TypeString:
        case TypeNumber:
        case TypeBoolean:
        case Plus:
        case Dash:
        case Tilde:
        case ParenOpen:
        case BracesOpen:
        case BracketOpen:
        case SemiColon:
        case Exclamation:
        case TemplateLiteralOpen:
        case DoublePlus:
        case DoubleDash:
        case If:
        case Do:
        case For:
        case Try:
        case Var:
        case With:
        case True:
        case Hash:
        case Null:
        case Break:
        case While:
        case Throw:
        case Array:
        case __Error:
        case False:
        case Regex:
        case Number:
        case Return:
        case Method:
        case Switch:
        case String:
        case Boolean:
        case LogInfo:
        case LogWarn:
        case Continue:
        case LogError:
        case LogDebug:
        case __Exception:
        case Identifier:
        case Integer:
        case Float:
        case DoubleQuotedString:
        case SingleQuotedString:
        case BackslashQuotedRegex:
          ClauseOrStatement(null);
          break;
        case Scope:
        case Global:
        case Require:
          ScopeDefinition(null);
          break;
        case Function:
          FunctionClauseWithOptionalScope(null);
          break;
        case LosBodyClose:
          LosBody(null);
          break;
        default:
          jj_la1[8] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TypeHash:
        case TypeVar:
        case TypeError:
        case TypeRegex:
        case TypeArray:
        case TypeMethod:
        case TypeString:
        case TypeNumber:
        case TypeBoolean:
        case Plus:
        case Dash:
        case Tilde:
        case ParenOpen:
        case BracesOpen:
        case BracketOpen:
        case SemiColon:
        case Exclamation:
        case TemplateLiteralOpen:
        case LosBodyClose:
        case DoublePlus:
        case DoubleDash:
        case If:
        case Do:
        case For:
        case Try:
        case Var:
        case With:
        case True:
        case Hash:
        case Null:
        case Break:
        case While:
        case Throw:
        case Array:
        case __Error:
        case Scope:
        case False:
        case Regex:
        case Number:
        case Return:
        case Method:
        case Switch:
        case Global:
        case String:
        case Boolean:
        case Require:
        case LogInfo:
        case LogWarn:
        case Continue:
        case Function:
        case LogError:
        case LogDebug:
        case __Exception:
        case Identifier:
        case Integer:
        case Float:
        case DoubleQuotedString:
        case SingleQuotedString:
        case BackslashQuotedRegex:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_4;
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void ScopeDefinition(EMethod method) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Require:
      ScopeExternal(method);
      break;
    case Global:
      ScopeGlobal(method);
      break;
    case Scope:
      ScopeManual(method);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ScopeGlobal(EMethod method) throws ParseException {
 /*@bgen(jjtree) ScopeGlobalNode */
  ASTScopeGlobalNode jjtn000 = new ASTScopeGlobalNode(this, JJTSCOPEGLOBALNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(Global);
      jj_consume_token(Scope);
      jj_consume_token(BracesOpen);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TypeHash:
        case TypeVar:
        case TypeError:
        case TypeRegex:
        case TypeArray:
        case TypeMethod:
        case TypeString:
        case TypeNumber:
        case TypeBoolean:
        case Var:
        case Hash:
        case Array:
        case __Error:
        case Regex:
        case Number:
        case Method:
        case String:
        case Boolean:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_5;
        }
        VariableDeclarationClause(null);
      }
      jj_consume_token(BracesClose);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void ScopeManual(EMethod method) throws ParseException {
 /*@bgen(jjtree) ScopeManualNode */
  ASTScopeManualNode jjtn000 = new ASTScopeManualNode(this, JJTSCOPEMANUALNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      jj_consume_token(Scope);
      t = jj_consume_token(Identifier);
      jj_consume_token(BracesOpen);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TypeHash:
        case TypeVar:
        case TypeError:
        case TypeRegex:
        case TypeArray:
        case TypeMethod:
        case TypeString:
        case TypeNumber:
        case TypeBoolean:
        case Var:
        case Hash:
        case Array:
        case __Error:
        case Regex:
        case Number:
        case Method:
        case String:
        case Boolean:
        case Function:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_6;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TypeHash:
        case TypeVar:
        case TypeError:
        case TypeRegex:
        case TypeArray:
        case TypeMethod:
        case TypeString:
        case TypeNumber:
        case TypeBoolean:
        case Var:
        case Hash:
        case Array:
        case __Error:
        case Regex:
        case Number:
        case Method:
        case String:
        case Boolean:
          VariableDeclarationClause(null);
          break;
        case Function:
          FunctionClause(null);
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(BracesClose);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t.getNonnullImage());
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void ScopeExternal(EMethod method) throws ParseException {
 /*@bgen(jjtree) ScopeExternalNode */
  ASTScopeExternalNode jjtn000 = new ASTScopeExternalNode(this, JJTSCOPEEXTERNALNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      jj_consume_token(Require);
      jj_consume_token(Scope);
      t = jj_consume_token(Identifier);
      jj_consume_token(SemiColon);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t.getNonnullImage());
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void ClauseOrStatement(EMethod method) throws ParseException {
    if (jj_2_1(2147483647)) {
      LabeledClause(method);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case For:
        ForLoop(method, null);
        break;
      case While:
        WhileLoop(method, null);
        break;
      case Do:
        DoWhileLoop(method, null);
        break;
      case Switch:
        SwitchClause(method, null);
        break;
      case If:
        IfClause(method);
        break;
      case Try:
        TryClause(method);
        break;
      case With:
        WithClause(method);
        break;
      case Throw:
        ThrowClause(method);
        break;
      case Break:
        BreakClause(method);
        break;
      case Continue:
        ContinueClause(method);
        break;
      case Return:
        ReturnClause(method);
        break;
      case TypeHash:
      case TypeVar:
      case TypeError:
      case TypeRegex:
      case TypeArray:
      case TypeMethod:
      case TypeString:
      case TypeNumber:
      case TypeBoolean:
      case Var:
      case Hash:
      case Array:
      case __Error:
      case Regex:
      case Number:
      case Method:
      case String:
      case Boolean:
        VariableDeclarationClause(method);
        break;
      case Plus:
      case Dash:
      case Tilde:
      case ParenOpen:
      case BracesOpen:
      case BracketOpen:
      case SemiColon:
      case Exclamation:
      case TemplateLiteralOpen:
      case DoublePlus:
      case DoubleDash:
      case True:
      case Null:
      case False:
      case LogInfo:
      case LogWarn:
      case LogError:
      case LogDebug:
      case __Exception:
      case Identifier:
      case Integer:
      case Float:
      case DoubleQuotedString:
      case SingleQuotedString:
      case BackslashQuotedRegex:
        Statement(method);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void LabeledClause(EMethod method) throws ParseException {
  Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Identifier:
      t = jj_consume_token(Identifier);
      jj_consume_token(Colon);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case For:
      ForLoop(method, t);
      break;
    case While:
      WhileLoop(method, t);
      break;
    case Do:
      DoWhileLoop(method, t);
      break;
    case Switch:
      SwitchClause(method, t);
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void VariableDeclarationClauseWithoutAssignment(EMethod method) throws ParseException {
 /*@bgen(jjtree) VariableDeclarationClauseNode */
  ASTVariableDeclarationClauseNode jjtn000 = new ASTVariableDeclarationClauseNode(this, JJTVARIABLEDECLARATIONCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      VariableType(null);
      t = jj_consume_token(Identifier);
      jj_consume_token(SemiColon);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t.getNonnullImage());
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void VariableDeclarationClause(EMethod method) throws ParseException {
 /*@bgen(jjtree) VariableDeclarationClauseNode */
  ASTVariableDeclarationClauseNode jjtn000 = new ASTVariableDeclarationClauseNode(this, JJTVARIABLEDECLARATIONCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      VariableType(null);
      t = jj_consume_token(Identifier);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Equal:
        jj_consume_token(Equal);
        Expression(null);
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      jj_consume_token(SemiColon);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t.getNonnullImage());
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public boolean FunctionArgument(EMethod method) throws ParseException {
 /*@bgen(jjtree) FunctionArgumentNode */
  ASTFunctionArgumentNode jjtn000 = new ASTFunctionArgumentNode(this, JJTFUNCTIONARGUMENTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
  boolean hasVarArg = false;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TypeHash:
      case TypeVar:
      case TypeError:
      case TypeRegex:
      case TypeArray:
      case TypeMethod:
      case TypeString:
      case TypeNumber:
      case TypeBoolean:
      case Var:
      case Hash:
      case Array:
      case __Error:
      case Regex:
      case Number:
      case Method:
      case String:
      case Boolean:
        VariableType(null);
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TripleDot:
        jj_consume_token(TripleDot);
                                              hasVarArg = true;
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      t = jj_consume_token(Identifier);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t.getNonnullImage());
    {if (true) return hasVarArg;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void VariableDeclarationExpressionWithAssignment(EMethod method) throws ParseException {
 /*@bgen(jjtree) VariableDeclarationClauseNode */
  ASTVariableDeclarationClauseNode jjtn000 = new ASTVariableDeclarationClauseNode(this, JJTVARIABLEDECLARATIONCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      VariableType(null);
      t = jj_consume_token(Identifier);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Equal:
        jj_consume_token(Equal);
        Expression(null);
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t.getNonnullImage());
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void VariableType(EMethod method) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TypeVar:
    case Var:
      UnspecificVariableType(method);
      break;
    case TypeHash:
    case TypeError:
    case TypeRegex:
    case TypeArray:
    case TypeMethod:
    case TypeString:
    case TypeNumber:
    case TypeBoolean:
    case Hash:
    case Array:
    case __Error:
    case Regex:
    case Number:
    case Method:
    case String:
    case Boolean:
      SpecificVariableType(method);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void UnspecificVariableType(EMethod method) throws ParseException {
 /*@bgen(jjtree) VariableTypeNode */
  ASTVariableTypeNode jjtn000 = new ASTVariableTypeNode(this, JJTVARIABLETYPENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Var:
        jj_consume_token(Var);
        break;
      case TypeVar:
        jj_consume_token(TypeVar);
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, ELangObjectClass.OBJECT);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void VoidVariableType(EMethod method) throws ParseException {
 /*@bgen(jjtree) VariableTypeNode */
  ASTVariableTypeNode jjtn000 = new ASTVariableTypeNode(this, JJTVARIABLETYPENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TypeVoid:
        jj_consume_token(TypeVoid);
        break;
      case Void:
        jj_consume_token(Void);
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, VoidClass.INSTANCE);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void SpecificVariableType(EMethod method) throws ParseException {
 /*@bgen(jjtree) VariableTypeNode */
  ASTVariableTypeNode jjtn000 = new ASTVariableTypeNode(this, JJTVARIABLETYPENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));ELangObjectClass type;
  EVariableTypeFlag flag = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TypeBoolean:
      case Boolean:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Boolean:
          jj_consume_token(Boolean);
          break;
        case TypeBoolean:
          jj_consume_token(TypeBoolean);
          break;
        default:
          jj_la1[24] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      type = ELangObjectClass.BOOLEAN;
        break;
      case TypeNumber:
      case Number:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Number:
          jj_consume_token(Number);
          break;
        case TypeNumber:
          jj_consume_token(TypeNumber);
          break;
        default:
          jj_la1[25] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      type = ELangObjectClass.NUMBER;
        break;
      case TypeString:
      case String:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case String:
          jj_consume_token(String);
          break;
        case TypeString:
          jj_consume_token(TypeString);
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      type = ELangObjectClass.STRING;
        break;
      case TypeArray:
      case Array:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Array:
          jj_consume_token(Array);
          break;
        case TypeArray:
          jj_consume_token(TypeArray);
          break;
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        GenericsArray(null);
        type = ELangObjectClass.ARRAY;
        break;
      case TypeHash:
      case Hash:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Hash:
          jj_consume_token(Hash);
          break;
        case TypeHash:
          jj_consume_token(TypeHash);
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        GenericsHash(null);
        type = ELangObjectClass.HASH;
        break;
      case TypeError:
      case __Error:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case __Error:
          jj_consume_token(__Error);
          break;
        case TypeError:
          jj_consume_token(TypeError);
          break;
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      type = ELangObjectClass.EXCEPTION;
        break;
      case TypeRegex:
      case Regex:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Regex:
          jj_consume_token(Regex);
          break;
        case TypeRegex:
          jj_consume_token(TypeRegex);
          break;
        default:
          jj_la1[30] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      type = ELangObjectClass.REGEX;
        break;
      case TypeMethod:
      case Method:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Method:
          jj_consume_token(Method);
          break;
        case TypeMethod:
          jj_consume_token(TypeMethod);
          break;
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        flag = GenericsMethod(null);
        type = ELangObjectClass.FUNCTION;
        break;
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, type, flag);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void GenericsHash(EMethod method) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AngleOpen:
      jj_consume_token(AngleOpen);
      break;
    case TypeAngleOpen:
      jj_consume_token(TypeAngleOpen);
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    VariableType(method);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Comma:
      jj_consume_token(Comma);
      break;
    case TypeComma:
      jj_consume_token(TypeComma);
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    VariableType(method);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AngleClose:
      jj_consume_token(AngleClose);
      break;
    case TypeAngleClose:
      jj_consume_token(TypeAngleClose);
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void GenericsArray(EMethod method) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AngleOpen:
      jj_consume_token(AngleOpen);
      break;
    case TypeAngleOpen:
      jj_consume_token(TypeAngleOpen);
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    VariableType(method);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AngleClose:
      jj_consume_token(AngleClose);
      break;
    case TypeAngleClose:
      jj_consume_token(TypeAngleClose);
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public EVariableTypeFlag GenericsMethod(EMethod method) throws ParseException {
  EVariableTypeFlag flag = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AngleOpen:
      jj_consume_token(AngleOpen);
      break;
    case TypeAngleOpen:
      jj_consume_token(TypeAngleOpen);
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TypeHash:
    case TypeVar:
    case TypeError:
    case TypeRegex:
    case TypeArray:
    case TypeMethod:
    case TypeString:
    case TypeNumber:
    case TypeBoolean:
    case Var:
    case Hash:
    case Array:
    case __Error:
    case Regex:
    case Number:
    case Method:
    case String:
    case Boolean:
      VariableType(method);
      break;
    case TypeVoid:
    case Void:
      VoidVariableType(method);
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TypeComma:
      case Comma:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Comma:
        jj_consume_token(Comma);
        break;
      case TypeComma:
        jj_consume_token(TypeComma);
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      VariableType(method);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TypeTripleDot:
    case TripleDot:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TripleDot:
        jj_consume_token(TripleDot);
        break;
      case TypeTripleDot:
        jj_consume_token(TypeTripleDot);
        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        flag = EVariableTypeFlag.VARARG;
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AngleClose:
      jj_consume_token(AngleClose);
      break;
    case TypeAngleClose:
      jj_consume_token(TypeAngleClose);
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return flag;}
    throw new Error("Missing return statement in function");
  }

  final public void GenericsFunction(EMethod method) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TypeHash:
    case TypeVar:
    case TypeError:
    case TypeRegex:
    case TypeArray:
    case TypeMethod:
    case TypeString:
    case TypeNumber:
    case TypeBoolean:
    case Var:
    case Hash:
    case Array:
    case __Error:
    case Regex:
    case Number:
    case Method:
    case String:
    case Boolean:
      VariableType(method);
      break;
    case TypeVoid:
    case Void:
      VoidVariableType(method);
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void FunctionClauseWithOptionalScope(EMethod method) throws ParseException {
 /*@bgen(jjtree) FunctionClauseNode */
  ASTFunctionClauseNode jjtn000 = new ASTFunctionClauseNode(this, JJTFUNCTIONCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
  boolean hasVarArg = false;
  boolean hasType = false;
    try {
      jj_consume_token(Function);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TypeHash:
      case TypeVar:
      case TypeVoid:
      case TypeError:
      case TypeRegex:
      case TypeArray:
      case TypeMethod:
      case TypeString:
      case TypeNumber:
      case TypeBoolean:
      case Var:
      case Hash:
      case Void:
      case Array:
      case __Error:
      case Regex:
      case Number:
      case Method:
      case String:
      case Boolean:
        GenericsFunction(null);
                               hasType = true;
        break;
      default:
        jj_la1[46] = jj_gen;
        ;
      }
      VariableWithOptionalScope(null);
      jj_consume_token(ParenOpen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TypeHash:
      case TypeVar:
      case TypeError:
      case TypeRegex:
      case TypeArray:
      case TypeMethod:
      case TypeString:
      case TypeNumber:
      case TypeBoolean:
      case TripleDot:
      case Var:
      case Hash:
      case Array:
      case __Error:
      case Regex:
      case Number:
      case Method:
      case String:
      case Boolean:
      case Identifier:
        hasVarArg = FunctionArgument(null);
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Comma:
            ;
            break;
          default:
            jj_la1[47] = jj_gen;
            break label_8;
          }
            if (hasVarArg)
              {if (true) throw new ParseException(CmnCnst.Error.VAR_ARG_IN_NON_FINAL_PLACE, token);}
          jj_consume_token(Comma);
          hasVarArg = FunctionArgument(null);
        }
        break;
      default:
        jj_la1[48] = jj_gen;
        ;
      }
      jj_consume_token(ParenClose);
      Block(null);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, hasVarArg, hasType);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void FunctionClause(EMethod method) throws ParseException {
 /*@bgen(jjtree) FunctionClauseNode */
  ASTFunctionClauseNode jjtn000 = new ASTFunctionClauseNode(this, JJTFUNCTIONCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
  boolean hasVarArg = false;
  boolean hasType = false;
    try {
      jj_consume_token(Function);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TypeHash:
      case TypeVar:
      case TypeVoid:
      case TypeError:
      case TypeRegex:
      case TypeArray:
      case TypeMethod:
      case TypeString:
      case TypeNumber:
      case TypeBoolean:
      case Var:
      case Hash:
      case Void:
      case Array:
      case __Error:
      case Regex:
      case Number:
      case Method:
      case String:
      case Boolean:
        GenericsFunction(null);
                               hasType = true;
        break;
      default:
        jj_la1[49] = jj_gen;
        ;
      }
      Variable(null);
      jj_consume_token(ParenOpen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TypeHash:
      case TypeVar:
      case TypeError:
      case TypeRegex:
      case TypeArray:
      case TypeMethod:
      case TypeString:
      case TypeNumber:
      case TypeBoolean:
      case TripleDot:
      case Var:
      case Hash:
      case Array:
      case __Error:
      case Regex:
      case Number:
      case Method:
      case String:
      case Boolean:
      case Identifier:
        hasVarArg = FunctionArgument(null);
        label_9:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Comma:
            ;
            break;
          default:
            jj_la1[50] = jj_gen;
            break label_9;
          }
            if (hasVarArg)
              {if (true) throw new ParseException(CmnCnst.Error.VAR_ARG_IN_NON_FINAL_PLACE, token);}
          jj_consume_token(Comma);
          hasVarArg = FunctionArgument(null);
        }
        break;
      default:
        jj_la1[51] = jj_gen;
        ;
      }
      jj_consume_token(ParenClose);
      Block(null);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, hasVarArg, hasType);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void WithClause(EMethod method) throws ParseException {
 /*@bgen(jjtree) WithClauseNode */
  ASTWithClauseNode jjtn000 = new ASTWithClauseNode(this, JJTWITHCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(With);
      jj_consume_token(ParenOpen);
      IdentifierName(null);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Comma:
          ;
          break;
        default:
          jj_la1[52] = jj_gen;
          break label_10;
        }
        jj_consume_token(Comma);
        IdentifierName(null);
      }
      jj_consume_token(ParenClose);
      BlockOrClause(null);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void ContinueClause(EMethod method) throws ParseException {
 /*@bgen(jjtree) ContinueClauseNode */
  ASTContinueClauseNode jjtn000 = new ASTContinueClauseNode(this, JJTCONTINUECLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t = null;
    try {
      jj_consume_token(Continue);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Identifier:
        t = jj_consume_token(Identifier);
        break;
      default:
        jj_la1[53] = jj_gen;
        ;
      }
      jj_consume_token(SemiColon);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t == null ? null : t.getNonnullImage());
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void BreakClause(EMethod method) throws ParseException {
 /*@bgen(jjtree) BreakClauseNode */
  ASTBreakClauseNode jjtn000 = new ASTBreakClauseNode(this, JJTBREAKCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t = null;
    try {
      jj_consume_token(Break);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Identifier:
        t = jj_consume_token(Identifier);
        break;
      default:
        jj_la1[54] = jj_gen;
        ;
      }
      jj_consume_token(SemiColon);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t == null ? null : t.getNonnullImage());
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void ReturnClause(EMethod method) throws ParseException {
 /*@bgen(jjtree) ReturnClauseNode */
  ASTReturnClauseNode jjtn000 = new ASTReturnClauseNode(this, JJTRETURNCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(Return);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Plus:
      case Dash:
      case Tilde:
      case ParenOpen:
      case BracesOpen:
      case BracketOpen:
      case Exclamation:
      case TemplateLiteralOpen:
      case DoublePlus:
      case DoubleDash:
      case True:
      case Null:
      case False:
      case LogInfo:
      case LogWarn:
      case LogError:
      case LogDebug:
      case __Exception:
      case Identifier:
      case Integer:
      case Float:
      case DoubleQuotedString:
      case SingleQuotedString:
      case BackslashQuotedRegex:
        Expression(null);
        break;
      default:
        jj_la1[55] = jj_gen;
        ;
      }
      jj_consume_token(SemiColon);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void ThrowClause(EMethod method) throws ParseException {
 /*@bgen(jjtree) ThrowClauseNode */
  ASTThrowClauseNode jjtn000 = new ASTThrowClauseNode(this, JJTTHROWCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(Throw);
      Expression(null);
      jj_consume_token(SemiColon);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void SwitchClause(EMethod method, Token label) throws ParseException {
 /*@bgen(jjtree) SwitchClauseNode */
  ASTSwitchClauseNode jjtn000 = new ASTSwitchClauseNode(this, JJTSWITCHCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));EMethod switchMethod = EMethod.SWITCHCLAUSE;
  int indexDefault = -1;
    try {
      jj_consume_token(Switch);
      jj_consume_token(ParenOpen);
      Expression(null);
      jj_consume_token(ParenClose);
      jj_consume_token(BracesOpen);
      indexDefault = SwitchBlockStatementGroup();
      jj_consume_token(BracesClose);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, label != null ? label.image : null, indexDefault);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public int SwitchBlockStatementGroup() throws ParseException {
  Token lastDefault = null;
  EMethod switchMethod;
  int index = 0;
  int indexDefault =-1;
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Case:
      case Default:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Case:
        jj_consume_token(Case);
        Expression(EMethod.SWITCHCASE);
        jj_consume_token(Colon);
            if (lastDefault != null)
                                {if (true) throw new ParseException(CmnCnst.Error.DEFAULT_CASE_MUST_BE_LAST, lastDefault);}
            switchMethod = EMethod.SWITCHCLAUSE;
            ++index;
        break;
      case Default:
        lastDefault = jj_consume_token(Default);
        jj_consume_token(Colon);
          if (indexDefault != - 1)
          {if (true) throw new ParseException(CmnCnst.Error.DEFAULT_USED_MULTIPLE_TIMES, token);}
          indexDefault = index;
          switchMethod = EMethod.SWITCHDEFAULT;
          ++index;
        break;
      default:
        jj_la1[57] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TypeHash:
        case TypeVar:
        case TypeError:
        case TypeRegex:
        case TypeArray:
        case TypeMethod:
        case TypeString:
        case TypeNumber:
        case TypeBoolean:
        case Plus:
        case Dash:
        case Tilde:
        case ParenOpen:
        case BracesOpen:
        case BracketOpen:
        case SemiColon:
        case Exclamation:
        case TemplateLiteralOpen:
        case DoublePlus:
        case DoubleDash:
        case If:
        case Do:
        case For:
        case Try:
        case Var:
        case With:
        case True:
        case Hash:
        case Null:
        case Break:
        case While:
        case Throw:
        case Array:
        case __Error:
        case False:
        case Regex:
        case Number:
        case Return:
        case Method:
        case Switch:
        case String:
        case Boolean:
        case LogInfo:
        case LogWarn:
        case Continue:
        case LogError:
        case LogDebug:
        case __Exception:
        case Identifier:
        case Integer:
        case Float:
        case DoubleQuotedString:
        case SingleQuotedString:
        case BackslashQuotedRegex:
          ;
          break;
        default:
          jj_la1[58] = jj_gen;
          break label_12;
        }
        ClauseOrStatement(switchMethod);
      }
    }
    {if (true) return indexDefault;}
    throw new Error("Missing return statement in function");
  }

/*
void SwitchClause(EMethod method, Token label) #SwitchClauseNode :
{
}
{
  (
    < Switch > < ParenOpen > Expression(null) < ParenClose > < BracesOpen >
    (
      SwitchCase()
    )*
    [SwitchDefault() ] 
    < BracesClose >
  )
  {
    jjtThis.init(method, label != null ? label.image : null);
  }
}

void SwitchCase() #void :
{
}
{
  (
    (
      < Case > Expression(EMethod.SWITCHCASE) < Colon >
    )+
    (
      ClauseOrStatement(EMethod.SWITCHCLAUSE)
    )+
  )
}
*/

/*
void SwitchDefault() #void :
{
}
{
  (
    < Default > < Colon >
    (
      ClauseOrStatement(EMethod.SWITCHDEFAULT)
    )+
  )
}
*/
  final public void TryClause(EMethod method) throws ParseException {
 /*@bgen(jjtree) TryClauseNode */
  ASTTryClauseNode jjtn000 = new ASTTryClauseNode(this, JJTTRYCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      jj_consume_token(Try);
      Block(null);
      jj_consume_token(Catch);
      jj_consume_token(ParenOpen);
      t = jj_consume_token(Identifier);
      jj_consume_token(ParenClose);
      Block(null);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t.getNonnullImage());
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void DoWhileLoop(EMethod method, Token label) throws ParseException {
 /*@bgen(jjtree) DoWhileLoopNode */
  ASTDoWhileLoopNode jjtn000 = new ASTDoWhileLoopNode(this, JJTDOWHILELOOPNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(Do);
      BlockOrClause(null);
      jj_consume_token(While);
      jj_consume_token(ParenOpen);
      Expression(null);
      jj_consume_token(ParenClose);
      jj_consume_token(SemiColon);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, label != null ? label.image : null);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void WhileLoop(EMethod method, Token label) throws ParseException {
 /*@bgen(jjtree) WhileLoopNode */
  ASTWhileLoopNode jjtn000 = new ASTWhileLoopNode(this, JJTWHILELOOPNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(While);
      jj_consume_token(ParenOpen);
      Expression(null);
      jj_consume_token(ParenClose);
      BlockOrClause(null);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, label != null ? label.image : null);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void ForLoop(EMethod method, Token label) throws ParseException {
 /*@bgen(jjtree) ForLoopNode */
  ASTForLoopNode jjtn000 = new ASTForLoopNode(this, JJTFORLOOPNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token iteratingLoopVariable = null;
  boolean hasType = false;
    try {
      jj_consume_token(For);
      jj_consume_token(ParenOpen);
      if (jj_2_2(2147483647)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TypeHash:
        case TypeVar:
        case TypeError:
        case TypeRegex:
        case TypeArray:
        case TypeMethod:
        case TypeString:
        case TypeNumber:
        case TypeBoolean:
        case Var:
        case Hash:
        case Array:
        case __Error:
        case Regex:
        case Number:
        case Method:
        case String:
        case Boolean:
          VariableType(null);
                               hasType = true;
          break;
        default:
          jj_la1[59] = jj_gen;
          ;
        }
        iteratingLoopVariable = jj_consume_token(Identifier);
        jj_consume_token(In);
        Expression(null);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TypeHash:
        case TypeVar:
        case TypeError:
        case TypeRegex:
        case TypeArray:
        case TypeMethod:
        case TypeString:
        case TypeNumber:
        case TypeBoolean:
        case Plus:
        case Dash:
        case Tilde:
        case ParenOpen:
        case BracesOpen:
        case BracketOpen:
        case SemiColon:
        case Exclamation:
        case TemplateLiteralOpen:
        case DoublePlus:
        case DoubleDash:
        case Var:
        case True:
        case Hash:
        case Null:
        case Array:
        case __Error:
        case False:
        case Regex:
        case Number:
        case Method:
        case String:
        case Boolean:
        case LogInfo:
        case LogWarn:
        case LogError:
        case LogDebug:
        case __Exception:
        case Identifier:
        case Integer:
        case Float:
        case DoubleQuotedString:
        case SingleQuotedString:
        case BackslashQuotedRegex:
          ExpressionOrVariableDeclarationListCommaSeparated(null);
          jj_consume_token(SemiColon);
          ExpressionListCommaSeparated(null);
          jj_consume_token(SemiColon);
          ExpressionListCommaSeparated(null);
          break;
        default:
          jj_la1[60] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(ParenClose);
      BlockOrClause(null);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method,
      iteratingLoopVariable != null ? iteratingLoopVariable.image : null,
      label != null ? label.image : null,
      hasType);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

// A dangling else binds to the closest if, which
// is what the default algorithm with a lookahead
// of 1 does.
  final public void IfClause(EMethod method) throws ParseException {
 /*@bgen(jjtree) IfClauseNode */
  ASTIfClauseNode jjtn000 = new ASTIfClauseNode(this, JJTIFCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(If);
      jj_consume_token(ParenOpen);
      Expression(null);
      jj_consume_token(ParenClose);
      BlockOrClause(null);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Else:
        jj_consume_token(Else);
        BlockOrClause(null);
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

// An opening brace might indicate either the begining of a
// block or the beginning of a hash. In order to avoid too
// much lookahead, the parser commits to it being a block
// when it sees an opening brace. If you want a hash literal,
// put it inside a block like this:
//    if (true) {
//        { foo: "bar" };
//    }
//
  final public void BlockOrClause(EMethod method) throws ParseException {
    if (jj_2_3(2147483647)) {
      Block(method);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TypeHash:
      case TypeVar:
      case TypeError:
      case TypeRegex:
      case TypeArray:
      case TypeMethod:
      case TypeString:
      case TypeNumber:
      case TypeBoolean:
      case Plus:
      case Dash:
      case Tilde:
      case ParenOpen:
      case BracesOpen:
      case BracketOpen:
      case SemiColon:
      case Exclamation:
      case TemplateLiteralOpen:
      case DoublePlus:
      case DoubleDash:
      case If:
      case Do:
      case For:
      case Try:
      case Var:
      case With:
      case True:
      case Hash:
      case Null:
      case Break:
      case While:
      case Throw:
      case Array:
      case __Error:
      case False:
      case Regex:
      case Number:
      case Return:
      case Method:
      case Switch:
      case String:
      case Boolean:
      case LogInfo:
      case LogWarn:
      case Continue:
      case LogError:
      case LogDebug:
      case __Exception:
      case Identifier:
      case Integer:
      case Float:
      case DoubleQuotedString:
      case SingleQuotedString:
      case BackslashQuotedRegex:
        ClauseOrStatement(method);
        break;
      default:
        jj_la1[62] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void Block(EMethod method) throws ParseException {
 /*@bgen(jjtree) #StatementListNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      jj_consume_token(BracesOpen);
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TypeHash:
        case TypeVar:
        case TypeError:
        case TypeRegex:
        case TypeArray:
        case TypeMethod:
        case TypeString:
        case TypeNumber:
        case TypeBoolean:
        case Plus:
        case Dash:
        case Tilde:
        case ParenOpen:
        case BracesOpen:
        case BracketOpen:
        case SemiColon:
        case Exclamation:
        case TemplateLiteralOpen:
        case LosBodyClose:
        case DoublePlus:
        case DoubleDash:
        case If:
        case Do:
        case For:
        case Try:
        case Var:
        case With:
        case True:
        case Hash:
        case Null:
        case Break:
        case While:
        case Throw:
        case Array:
        case __Error:
        case False:
        case Regex:
        case Number:
        case Return:
        case Method:
        case Switch:
        case String:
        case Boolean:
        case LogInfo:
        case LogWarn:
        case Continue:
        case LogError:
        case LogDebug:
        case __Exception:
        case Identifier:
        case Integer:
        case Float:
        case DoubleQuotedString:
        case SingleQuotedString:
        case BackslashQuotedRegex:
          ;
          break;
        default:
          jj_la1[63] = jj_gen;
          break label_13;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TypeHash:
        case TypeVar:
        case TypeError:
        case TypeRegex:
        case TypeArray:
        case TypeMethod:
        case TypeString:
        case TypeNumber:
        case TypeBoolean:
        case Plus:
        case Dash:
        case Tilde:
        case ParenOpen:
        case BracesOpen:
        case BracketOpen:
        case SemiColon:
        case Exclamation:
        case TemplateLiteralOpen:
        case DoublePlus:
        case DoubleDash:
        case If:
        case Do:
        case For:
        case Try:
        case Var:
        case With:
        case True:
        case Hash:
        case Null:
        case Break:
        case While:
        case Throw:
        case Array:
        case __Error:
        case False:
        case Regex:
        case Number:
        case Return:
        case Method:
        case Switch:
        case String:
        case Boolean:
        case LogInfo:
        case LogWarn:
        case Continue:
        case LogError:
        case LogDebug:
        case __Exception:
        case Identifier:
        case Integer:
        case Float:
        case DoubleQuotedString:
        case SingleQuotedString:
        case BackslashQuotedRegex:
          ClauseOrStatement(null);
          break;
        case LosBodyClose:
          LosBody(null);
          break;
        default:
          jj_la1[64] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(BracesClose);
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) {
      jjtn000.init(method);
    }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void ExpressionOrVariableDeclarationListCommaSeparated(EMethod method) throws ParseException {
 /*@bgen(jjtree) StatementListNode */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TypeHash:
      case TypeVar:
      case TypeError:
      case TypeRegex:
      case TypeArray:
      case TypeMethod:
      case TypeString:
      case TypeNumber:
      case TypeBoolean:
      case Plus:
      case Dash:
      case Tilde:
      case ParenOpen:
      case BracesOpen:
      case BracketOpen:
      case Exclamation:
      case TemplateLiteralOpen:
      case DoublePlus:
      case DoubleDash:
      case Var:
      case True:
      case Hash:
      case Null:
      case Array:
      case __Error:
      case False:
      case Regex:
      case Number:
      case Method:
      case String:
      case Boolean:
      case LogInfo:
      case LogWarn:
      case LogError:
      case LogDebug:
      case __Exception:
      case Identifier:
      case Integer:
      case Float:
      case DoubleQuotedString:
      case SingleQuotedString:
      case BackslashQuotedRegex:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TypeHash:
        case TypeVar:
        case TypeError:
        case TypeRegex:
        case TypeArray:
        case TypeMethod:
        case TypeString:
        case TypeNumber:
        case TypeBoolean:
        case Var:
        case Hash:
        case Array:
        case __Error:
        case Regex:
        case Number:
        case Method:
        case String:
        case Boolean:
          VariableDeclarationExpressionWithAssignment(null);
          break;
        case Plus:
        case Dash:
        case Tilde:
        case ParenOpen:
        case BracesOpen:
        case BracketOpen:
        case Exclamation:
        case TemplateLiteralOpen:
        case DoublePlus:
        case DoubleDash:
        case True:
        case Null:
        case False:
        case LogInfo:
        case LogWarn:
        case LogError:
        case LogDebug:
        case __Exception:
        case Identifier:
        case Integer:
        case Float:
        case DoubleQuotedString:
        case SingleQuotedString:
        case BackslashQuotedRegex:
          Expression(null);
          break;
        default:
          jj_la1[65] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_14:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Comma:
            ;
            break;
          default:
            jj_la1[66] = jj_gen;
            break label_14;
          }
          jj_consume_token(Comma);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Plus:
          case Dash:
          case Tilde:
          case ParenOpen:
          case BracesOpen:
          case BracketOpen:
          case Exclamation:
          case TemplateLiteralOpen:
          case DoublePlus:
          case DoubleDash:
          case True:
          case Null:
          case False:
          case LogInfo:
          case LogWarn:
          case LogError:
          case LogDebug:
          case __Exception:
          case Identifier:
          case Integer:
          case Float:
          case DoubleQuotedString:
          case SingleQuotedString:
          case BackslashQuotedRegex:
            Expression(null);
            break;
          case TypeHash:
          case TypeVar:
          case TypeError:
          case TypeRegex:
          case TypeArray:
          case TypeMethod:
          case TypeString:
          case TypeNumber:
          case TypeBoolean:
          case Var:
          case Hash:
          case Array:
          case __Error:
          case Regex:
          case Number:
          case Method:
          case String:
          case Boolean:
            VariableDeclarationExpressionWithAssignment(null);
            break;
          default:
            jj_la1[67] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[68] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void ExpressionListCommaSeparated(EMethod method) throws ParseException {
 /*@bgen(jjtree) StatementListNode */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Plus:
      case Dash:
      case Tilde:
      case ParenOpen:
      case BracesOpen:
      case BracketOpen:
      case Exclamation:
      case TemplateLiteralOpen:
      case DoublePlus:
      case DoubleDash:
      case True:
      case Null:
      case False:
      case LogInfo:
      case LogWarn:
      case LogError:
      case LogDebug:
      case __Exception:
      case Identifier:
      case Integer:
      case Float:
      case DoubleQuotedString:
      case SingleQuotedString:
      case BackslashQuotedRegex:
        Expression(null);
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Comma:
            ;
            break;
          default:
            jj_la1[69] = jj_gen;
            break label_15;
          }
          jj_consume_token(Comma);
          Expression(null);
        }
        break;
      default:
        jj_la1[70] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void Statement(EMethod method) throws ParseException {
 /*@bgen(jjtree) #StatementListNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Plus:
      case Dash:
      case Tilde:
      case ParenOpen:
      case BracesOpen:
      case BracketOpen:
      case Exclamation:
      case TemplateLiteralOpen:
      case DoublePlus:
      case DoubleDash:
      case True:
      case Null:
      case False:
      case LogInfo:
      case LogWarn:
      case LogError:
      case LogDebug:
      case __Exception:
      case Identifier:
      case Integer:
      case Float:
      case DoubleQuotedString:
      case SingleQuotedString:
      case BackslashQuotedRegex:
        Expression(method);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SemiColon:
          jj_consume_token(SemiColon);
          break;
        case LosBodyClose:
          LosBody(null);
          break;
        default:
          jj_la1[71] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case SemiColon:
        EmptyStatement(method);
        break;
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) {
      jjtn000.init(method);

    }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public Node EmptyStatement(EMethod method) throws ParseException {
 /*@bgen(jjtree) EmptyNode */
  ASTEmptyNode jjtn000 = new ASTEmptyNode(this, JJTEMPTYNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(SemiColon);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);

    {if (true) return jjtn000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void Expression(EMethod method) throws ParseException {
    EqualTypeExpression(method);
  }

  final public void EqualTypeExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #AssignmentExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTAssignmentExpressionNode jjtn000 = new ASTAssignmentExpressionNode(this, JJTASSIGNMENTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      TernaryExpression(method);
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Equal:
        case PlusEqual:
        case DashEqual:
        case StarEqual:
        case SlashEqual:
        case PercentEqual:
        case AmpersandEqual:
        case BarEqual:
        case CircumflexEqual:
        case DoubleStarEqual:
        case DoubleAngleOpenEqual:
        case DoubleAngleCloseEqual:
        case TripleAngleOpenEqual:
        case TripleAngleCloseEqual:
          ;
          break;
        default:
          jj_la1[73] = jj_gen;
          break label_16;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Equal:
          jj_consume_token(Equal);
          TernaryExpression(EMethod.EQUAL);
          break;
        case PlusEqual:
          jj_consume_token(PlusEqual);
          TernaryExpression(EMethod.PLUS_EQUAL);
          break;
        case DashEqual:
          jj_consume_token(DashEqual);
          TernaryExpression(EMethod.DASH_EQUAL);
          break;
        case DoubleStarEqual:
          jj_consume_token(DoubleStarEqual);
          TernaryExpression(EMethod.DOUBLE_STAR_EQUAL);
          break;
        case StarEqual:
          jj_consume_token(StarEqual);
          TernaryExpression(EMethod.STAR_EQUAL);
          break;
        case SlashEqual:
          jj_consume_token(SlashEqual);
          TernaryExpression(EMethod.SLASH_EQUAL);
          break;
        case PercentEqual:
          jj_consume_token(PercentEqual);
          TernaryExpression(EMethod.PERCENT_EQUAL);
          break;
        case DoubleAngleOpenEqual:
          jj_consume_token(DoubleAngleOpenEqual);
          TernaryExpression(EMethod.DOUBLE_ANGLE_OPEN_EQUAL);
          break;
        case DoubleAngleCloseEqual:
          jj_consume_token(DoubleAngleCloseEqual);
          TernaryExpression(EMethod.DOUBLE_ANGLE_CLOSE_EQUAL);
          break;
        case TripleAngleOpenEqual:
          jj_consume_token(TripleAngleOpenEqual);
          TernaryExpression(EMethod.TRIPLE_ANGLE_OPEN_EQUAL);
          break;
        case TripleAngleCloseEqual:
          jj_consume_token(TripleAngleCloseEqual);
          TernaryExpression(EMethod.TRIPLE_ANGLE_CLOSE_EQUAL);
          break;
        case AmpersandEqual:
          jj_consume_token(AmpersandEqual);
          TernaryExpression(EMethod.AMPERSAND_EQUAL);
          break;
        case CircumflexEqual:
          jj_consume_token(CircumflexEqual);
          TernaryExpression(EMethod.CIRCUMFLEX_EQUAL);
          break;
        case BarEqual:
          jj_consume_token(BarEqual);
          TernaryExpression(EMethod.BAR_EQUAL);
          break;
        default:
          jj_la1[74] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void TernaryExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #TernaryExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTTernaryExpressionNode jjtn000 = new ASTTernaryExpressionNode(this, JJTTERNARYEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      DoubleBarExpression(method);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QuestionMark:
        jj_consume_token(QuestionMark);
        DoubleBarExpression(method);
        jj_consume_token(Colon);
        DoubleBarExpression(method);
        break;
      default:
        jj_la1[75] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void DoubleBarExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      DoubleAmpersandExpression(method);
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DoubleBar:
          ;
          break;
        default:
          jj_la1[76] = jj_gen;
          break label_17;
        }
        jj_consume_token(DoubleBar);
        DoubleAmpersandExpression(EMethod.DOUBLE_BAR);
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void DoubleAmpersandExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      BarExpression(method);
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DoubleAmpersand:
          ;
          break;
        default:
          jj_la1[77] = jj_gen;
          break label_18;
        }
        jj_consume_token(DoubleAmpersand);
        BarExpression(EMethod.DOUBLE_AMPERSAND);
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void BarExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      CircumflexExpression(method);
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Bar:
          ;
          break;
        default:
          jj_la1[78] = jj_gen;
          break label_19;
        }
        jj_consume_token(Bar);
        CircumflexExpression(EMethod.BAR);
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void CircumflexExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      AmpersandExpression(method);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Circumflex:
          ;
          break;
        default:
          jj_la1[79] = jj_gen;
          break label_20;
        }
        jj_consume_token(Circumflex);
        AmpersandExpression(EMethod.CIRCUMFLEX);
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void AmpersandExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      DoubleEqualTypeExpression(method);
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Ampersand:
          ;
          break;
        default:
          jj_la1[80] = jj_gen;
          break label_21;
        }
        jj_consume_token(Ampersand);
        DoubleEqualTypeExpression(EMethod.AMPERSAND);
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void DoubleEqualTypeExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #EqualExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTEqualExpressionNode jjtn000 = new ASTEqualExpressionNode(this, JJTEQUALEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      AngleTypeExpression(method);
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DoubleEqual:
        case ExclamationEqual:
        case EqualTilde:
        case ExclamationTilde:
        case TripleEqual:
        case ExclamationDoubleEqual:
          ;
          break;
        default:
          jj_la1[81] = jj_gen;
          break label_22;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ExclamationTilde:
          jj_consume_token(ExclamationTilde);
          AngleTypeExpression(EMethod.EXCLAMATION_TILDE);
          break;
        case EqualTilde:
          jj_consume_token(EqualTilde);
          AngleTypeExpression(EMethod.EQUAL_TILDE);
          break;
        case TripleEqual:
          jj_consume_token(TripleEqual);
          AngleTypeExpression(EMethod.TRIPLE_EQUAL);
          break;
        case DoubleEqual:
          jj_consume_token(DoubleEqual);
          AngleTypeExpression(EMethod.DOUBLE_EQUAL);
          break;
        case ExclamationDoubleEqual:
          jj_consume_token(ExclamationDoubleEqual);
          AngleTypeExpression(EMethod.EXCLAMATION_DOUBLE_EQUAL);
          break;
        case ExclamationEqual:
          jj_consume_token(ExclamationEqual);
          AngleTypeExpression(EMethod.EXCLAMATION_EQUAL);
          break;
        default:
          jj_la1[82] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) {

      jjtn000.init(method);
    }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void AngleTypeExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #ComparisonExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTComparisonExpressionNode jjtn000 = new ASTComparisonExpressionNode(this, JJTCOMPARISONEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      MultiAngleExpression(method);
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AngleOpen:
        case AngleClose:
        case AngleOpenEqual:
        case AngleCloseEqual:
          ;
          break;
        default:
          jj_la1[83] = jj_gen;
          break label_23;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AngleOpen:
          jj_consume_token(AngleOpen);
          MultiAngleExpression(EMethod.ANGLE_OPEN);
          break;
        case AngleClose:
          jj_consume_token(AngleClose);
          MultiAngleExpression(EMethod.ANGLE_CLOSE);
          break;
        case AngleOpenEqual:
          jj_consume_token(AngleOpenEqual);
          MultiAngleExpression(EMethod.ANGLE_OPEN_EQUAL);
          break;
        case AngleCloseEqual:
          jj_consume_token(AngleCloseEqual);
          MultiAngleExpression(EMethod.ANGLE_CLOSE_EQUAL);
          break;
        default:
          jj_la1[84] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void MultiAngleExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      PlusLikeExpression(method);
      label_24:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DoubleAngleOpen:
        case DoubleAngleClose:
        case TripleAngleOpen:
        case TripleAngleClose:
          ;
          break;
        default:
          jj_la1[85] = jj_gen;
          break label_24;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DoubleAngleOpen:
          jj_consume_token(DoubleAngleOpen);
          PlusLikeExpression(EMethod.DOUBLE_ANGLE_OPEN);
          break;
        case DoubleAngleClose:
          jj_consume_token(DoubleAngleClose);
          PlusLikeExpression(EMethod.DOUBLE_ANGLE_CLOSE);
          break;
        case TripleAngleOpen:
          jj_consume_token(TripleAngleOpen);
          PlusLikeExpression(EMethod.TRIPLE_ANGLE_OPEN);
          break;
        case TripleAngleClose:
          jj_consume_token(TripleAngleClose);
          PlusLikeExpression(EMethod.TRIPLE_ANGLE_CLOSE);
          break;
        default:
          jj_la1[86] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void PlusLikeExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      StarLikeExpression(method);
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Plus:
        case Dash:
          ;
          break;
        default:
          jj_la1[87] = jj_gen;
          break label_25;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Plus:
          jj_consume_token(Plus);
          StarLikeExpression(EMethod.PLUS);
          break;
        case Dash:
          jj_consume_token(Dash);
          StarLikeExpression(EMethod.DASH);
          break;
        default:
          jj_la1[88] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void StarLikeExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      DoubleStarExpression(method);
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Star:
        case Slash:
        case Percent:
          ;
          break;
        default:
          jj_la1[89] = jj_gen;
          break label_26;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Star:
          jj_consume_token(Star);
          DoubleStarExpression(EMethod.STAR);
          break;
        case Slash:
          jj_consume_token(Slash);
          DoubleStarExpression(EMethod.SLASH);
          break;
        case Percent:
          jj_consume_token(Percent);
          DoubleStarExpression(EMethod.PERCENT);
          break;
        default:
          jj_la1[90] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void DoubleStarExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode;
    try {
      UnaryExpression(method);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DoubleStar:
        jj_consume_token(DoubleStar);
        DoubleStarExpression(EMethod.DOUBLE_STAR);
        break;
      default:
        jj_la1[91] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void UnaryExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #UnaryExpressionNode( unaryMethod != null) */
  ASTUnaryExpressionNode jjtn000 = new ASTUnaryExpressionNode(this, JJTUNARYEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));EMethod unaryMethod = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DoublePlus:
        jj_consume_token(DoublePlus);
        UnaryExpression(method);
        unaryMethod = EMethod.DOUBLE_PLUS_PREFIX;
        break;
      case DoubleDash:
        jj_consume_token(DoubleDash);
        UnaryExpression(method);
        unaryMethod = EMethod.DOUBLE_DASH_PREFIX;
        break;
      case Plus:
        jj_consume_token(Plus);
        UnaryExpression(method);
        unaryMethod = EMethod.PLUS_UNARY;
        break;
      case Dash:
        jj_consume_token(Dash);
        UnaryExpression(method);
        unaryMethod = EMethod.DASH_UNARY;
        break;
      case Tilde:
        jj_consume_token(Tilde);
        UnaryExpression(method);
        unaryMethod = EMethod.TILDE;
        break;
      case Exclamation:
        jj_consume_token(Exclamation);
        UnaryExpression(method);
        unaryMethod = EMethod.EXCLAMATION;
        break;
      case ParenOpen:
      case BracesOpen:
      case BracketOpen:
      case TemplateLiteralOpen:
      case True:
      case Null:
      case False:
      case LogInfo:
      case LogWarn:
      case LogError:
      case LogDebug:
      case __Exception:
      case Identifier:
      case Integer:
      case Float:
      case DoubleQuotedString:
      case SingleQuotedString:
      case BackslashQuotedRegex:
        PostUnaryExpression(method);
        break;
      default:
        jj_la1[92] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000,  unaryMethod != null);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (unaryMethod != null) {

      jjtn000.init(method, unaryMethod);
    }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  unaryMethod != null);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void PostUnaryExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #PostUnaryExpressionNode( unaryMethod != null) */
  ASTPostUnaryExpressionNode jjtn000 = new ASTPostUnaryExpressionNode(this, JJTPOSTUNARYEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));EMethod unaryMethod = null;
    try {
      PropertyExpression(method);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DoublePlus:
      case DoubleDash:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DoublePlus:
          jj_consume_token(DoublePlus);
                        unaryMethod = EMethod.DOUBLE_PLUS_SUFFIX;
          break;
        case DoubleDash:
          jj_consume_token(DoubleDash);
                        unaryMethod = EMethod.DOUBLE_DASH_SUFFIX;
          break;
        default:
          jj_la1[93] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[94] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000,  unaryMethod != null);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (unaryMethod != null) {

      jjtn000.init(method, unaryMethod);
    }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  unaryMethod != null);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void PropertyExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #PropertyExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTPropertyExpressionNode jjtn000 = new ASTPropertyExpressionNode(this, JJTPROPERTYEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode = true;
    try {
      FunctionTypeUnaryExpression(method);
      label_27:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ParenOpen:
        case BracketOpen:
        case Dot:
          ;
          break;
        default:
          jj_la1[95] = jj_gen;
          break label_27;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Dot:
          jj_consume_token(Dot);
          DotProperty(EMethod.DOT);
          break;
        case BracketOpen:
          jj_consume_token(BracketOpen);
          Expression(EMethod.BRACKET);
          jj_consume_token(BracketClose);
          break;
        case ParenOpen:
          jj_consume_token(ParenOpen);
          FunctionArgumentList(EMethod.PARENTHESIS);
          jj_consume_token(ParenClose);
          break;
        default:
          jj_la1[96] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) {

      jjtn000.init(method);
    }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void DotProperty(EMethod method) throws ParseException {
 /*@bgen(jjtree) DotPropertyNode */
  ASTDotPropertyNode jjtn000 = new ASTDotPropertyNode(this, JJTDOTPROPERTYNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AngleOpen:
        jj_consume_token(AngleOpen);
        VariableType(null);
        label_28:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Comma:
            ;
            break;
          default:
            jj_la1[97] = jj_gen;
            break label_28;
          }
          jj_consume_token(Comma);
          VariableType(null);
        }
        jj_consume_token(AngleClose);
        break;
      default:
        jj_la1[98] = jj_gen;
        ;
      }
      t = jj_consume_token(Identifier);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t.getNonnullImage());
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void IdentifierName(EMethod method) throws ParseException {
 /*@bgen(jjtree) IdentifierNameNode */
  ASTIdentifierNameNode jjtn000 = new ASTIdentifierNameNode(this, JJTIDENTIFIERNAMENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(Identifier);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t.getNonnullImage());
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void FunctionArgumentList(EMethod method) throws ParseException {
 /*@bgen(jjtree) ArrayNode */
  ASTArrayNode jjtn000 = new ASTArrayNode(this, JJTARRAYNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Plus:
      case Dash:
      case Tilde:
      case ParenOpen:
      case BracesOpen:
      case BracketOpen:
      case Exclamation:
      case TemplateLiteralOpen:
      case DoublePlus:
      case DoubleDash:
      case True:
      case Null:
      case False:
      case LogInfo:
      case LogWarn:
      case LogError:
      case LogDebug:
      case __Exception:
      case Identifier:
      case Integer:
      case Float:
      case DoubleQuotedString:
      case SingleQuotedString:
      case BackslashQuotedRegex:
        Expression(null);
        break;
      default:
        jj_la1[99] = jj_gen;
        ;
      }
      label_29:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Comma:
          ;
          break;
        default:
          jj_la1[100] = jj_gen;
          break label_29;
        }
        jj_consume_token(Comma);
        Expression(null);
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void FunctionTypeUnaryExpression(EMethod method) throws ParseException {
 /*@bgen(jjtree) #ParenthesisExpressionNode( createNode) */
  ASTParenthesisExpressionNode jjtn000 = new ASTParenthesisExpressionNode(this, JJTPARENTHESISEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean createNode = false;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Identifier:
        VariableWithOptionalScope(method);
        break;
      case BracesOpen:
      case BracketOpen:
      case TemplateLiteralOpen:
      case True:
      case Null:
      case False:
      case LogInfo:
      case LogWarn:
      case LogError:
      case LogDebug:
      case __Exception:
      case Integer:
      case Float:
      case DoubleQuotedString:
      case SingleQuotedString:
      case BackslashQuotedRegex:
        LiteralWithoutFunction(method);
        break;
      default:
        jj_la1[101] = jj_gen;
        if (jj_2_4(4)) {
          Function(method);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ParenOpen:
            jj_consume_token(ParenOpen);
            Expression(method);
            jj_consume_token(ParenClose);
                                                          createNode = true;
            break;
          default:
            jj_la1[102] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    jjtree.closeNodeScope(jjtn000,  createNode);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (createNode) {
      jjtn000.init(method);
    }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void Variable(EMethod method) throws ParseException {
 /*@bgen(jjtree) VariableNode */
  ASTVariableNode jjtn000 = new ASTVariableNode(this, JJTVARIABLENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(Identifier);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, null, t.getNonnullImage());
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void VariableWithOptionalScope(EMethod method) throws ParseException {
 /*@bgen(jjtree) VariableNode */
  ASTVariableNode jjtn000 = new ASTVariableNode(this, JJTVARIABLENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token part1;
  Token part2 = null;
    try {
      part1 = jj_consume_token(Identifier);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ScopeSeparator:
        jj_consume_token(ScopeSeparator);
        part2 = jj_consume_token(Identifier);
        break;
      default:
        jj_la1[103] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    if (part2 == null)
      jjtn000.init(method, null, part1.getNonnullImage());
    else
      jjtn000.init(method, part1.image, part2.getNonnullImage());
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void Number(EMethod method) throws ParseException {
 /*@bgen(jjtree) NumberNode */
  ASTNumberNode jjtn000 = new ASTNumberNode(this, JJTNUMBERNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
  boolean isInt;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Integer:
        t = jj_consume_token(Integer);
      isInt = true;
        break;
      case Float:
        t = jj_consume_token(Float);
      isInt = false;
        break;
      default:
        jj_la1[104] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t.getNonnullImage(), isInt);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void String(EMethod method) throws ParseException {
 /*@bgen(jjtree) StringNode */
  ASTStringNode jjtn000 = new ASTStringNode(this, JJTSTRINGNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));char delimiter;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DoubleQuotedString:
      case SingleQuotedString:
        delimiter = StringLiteral(null);
        break;
      case TemplateLiteralOpen:
        jj_consume_token(TemplateLiteralOpen);
        label_30:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TemplateLiteralInlineOpen:
          case TemplateLiteralChars:
            ;
            break;
          default:
            jj_la1[105] = jj_gen;
            break label_30;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TemplateLiteralChars:
            TemplateLiteralCharacters(null);
            break;
          case TemplateLiteralInlineOpen:
            jj_consume_token(TemplateLiteralInlineOpen);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case Plus:
            case Dash:
            case Tilde:
            case ParenOpen:
            case BracesOpen:
            case BracketOpen:
            case Exclamation:
            case TemplateLiteralOpen:
            case DoublePlus:
            case DoubleDash:
            case True:
            case Null:
            case False:
            case LogInfo:
            case LogWarn:
            case LogError:
            case LogDebug:
            case __Exception:
            case Identifier:
            case Integer:
            case Float:
            case DoubleQuotedString:
            case SingleQuotedString:
            case BackslashQuotedRegex:
              Expression(null);
              break;
            default:
              jj_la1[106] = jj_gen;
              ;
            }
            jj_consume_token(BracesClose);
            break;
          default:
            jj_la1[107] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        jj_consume_token(TemplateLiteralClose);
        delimiter = '`';
        break;
      default:
        jj_la1[108] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, delimiter);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public char StringLiteral(EMethod method) throws ParseException {
 /*@bgen(jjtree) StringCharactersNode */
  ASTStringCharactersNode jjtn000 = new ASTStringCharactersNode(this, JJTSTRINGCHARACTERSNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
  char delimiter;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DoubleQuotedString:
        t = jj_consume_token(DoubleQuotedString);
                                 delimiter = '"';
        break;
      case SingleQuotedString:
        t = jj_consume_token(SingleQuotedString);
                                 delimiter = '\u005c'';
        break;
      default:
        jj_la1[109] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    String image = t.getNonnullImage();
    jjtn000.init(method, image.substring(1, image.length()-1), delimiter);
    {if (true) return delimiter;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void TemplateLiteralCharacters(EMethod method) throws ParseException {
 /*@bgen(jjtree) StringCharactersNode */
  ASTStringCharactersNode jjtn000 = new ASTStringCharactersNode(this, JJTSTRINGCHARACTERSNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(TemplateLiteralChars);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t.getNonnullImage(), '`');
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void Array(EMethod method) throws ParseException {
 /*@bgen(jjtree) ArrayNode */
  ASTArrayNode jjtn000 = new ASTArrayNode(this, JJTARRAYNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(BracketOpen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BracketClose:
        jj_consume_token(BracketClose);
        break;
      case Plus:
      case Dash:
      case Tilde:
      case ParenOpen:
      case BracesOpen:
      case BracketOpen:
      case Exclamation:
      case TemplateLiteralOpen:
      case DoublePlus:
      case DoubleDash:
      case True:
      case Null:
      case False:
      case LogInfo:
      case LogWarn:
      case LogError:
      case LogDebug:
      case __Exception:
      case Identifier:
      case Integer:
      case Float:
      case DoubleQuotedString:
      case SingleQuotedString:
      case BackslashQuotedRegex:
        Expression(null);
        label_31:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Comma:
            ;
            break;
          default:
            jj_la1[110] = jj_gen;
            break label_31;
          }
          jj_consume_token(Comma);
          Expression(null);
        }
        jj_consume_token(BracketClose);
        break;
      default:
        jj_la1[111] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void Hash(EMethod method) throws ParseException {
 /*@bgen(jjtree) HashNode */
  ASTHashNode jjtn000 = new ASTHashNode(this, JJTHASHNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(BracesOpen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BracesClose:
        jj_consume_token(BracesClose);
        break;
      case ParenOpen:
      case BracesOpen:
      case BracketOpen:
      case TemplateLiteralOpen:
      case True:
      case Null:
      case False:
      case LogInfo:
      case LogWarn:
      case LogError:
      case LogDebug:
      case __Exception:
      case Identifier:
      case Integer:
      case Float:
      case DoubleQuotedString:
      case SingleQuotedString:
      case BackslashQuotedRegex:
        HashEntry(null);
        label_32:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Comma:
            ;
            break;
          default:
            jj_la1[112] = jj_gen;
            break label_32;
          }
          jj_consume_token(Comma);
          HashEntry(null);
        }
        jj_consume_token(BracesClose);
        break;
      default:
        jj_la1[113] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void HashEntry(EMethod method) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ParenOpen:
    case BracesOpen:
    case BracketOpen:
    case TemplateLiteralOpen:
    case True:
    case Null:
    case False:
    case LogInfo:
    case LogWarn:
    case LogError:
    case LogDebug:
    case __Exception:
    case Integer:
    case Float:
    case DoubleQuotedString:
    case SingleQuotedString:
    case BackslashQuotedRegex:
      Literal(null);
      break;
    case Identifier:
      IdentifierName(null);
      break;
    default:
      jj_la1[114] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(Colon);
    Expression(null);
  }

  final public void Null(EMethod method) throws ParseException {
 /*@bgen(jjtree) NullNode */
  ASTNullNode jjtn000 = new ASTNullNode(this, JJTNULLNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(Null);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    {
      jjtn000.init(method);
    }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void Boolean(EMethod method) throws ParseException {
 /*@bgen(jjtree) BooleanNode */
  ASTBooleanNode jjtn000 = new ASTBooleanNode(this, JJTBOOLEANNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean b;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case True:
        jj_consume_token(True);
      b = true;
        break;
      case False:
        jj_consume_token(False);
      b = false;
        break;
      default:
        jj_la1[115] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, b);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void Log(EMethod method) throws ParseException {
 /*@bgen(jjtree) LogNode */
  ASTLogNode jjtn000 = new ASTLogNode(this, JJTLOGNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));ELogLevel logLevel;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LogInfo:
        jj_consume_token(LogInfo);
        logLevel = ELogLevel.INFO;
        break;
      case LogError:
        jj_consume_token(LogError);
        logLevel = ELogLevel.ERROR;
        break;
      case LogDebug:
        jj_consume_token(LogDebug);
        logLevel = ELogLevel.DEBUG;
        break;
      case LogWarn:
        jj_consume_token(LogWarn);
        logLevel = ELogLevel.WARN;
        break;
      default:
        jj_la1[116] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(ParenOpen);
      Expression(null);
      jj_consume_token(ParenClose);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, logLevel);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void Exception(EMethod method) throws ParseException {
 /*@bgen(jjtree) ExceptionNode */
  ASTExceptionNode jjtn000 = new ASTExceptionNode(this, JJTEXCEPTIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(__Exception);
      jj_consume_token(ParenOpen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Plus:
      case Dash:
      case Tilde:
      case ParenOpen:
      case BracesOpen:
      case BracketOpen:
      case Exclamation:
      case TemplateLiteralOpen:
      case DoublePlus:
      case DoubleDash:
      case True:
      case Null:
      case False:
      case LogInfo:
      case LogWarn:
      case LogError:
      case LogDebug:
      case __Exception:
      case Identifier:
      case Integer:
      case Float:
      case DoubleQuotedString:
      case SingleQuotedString:
      case BackslashQuotedRegex:
        Expression(null);
        break;
      default:
        jj_la1[117] = jj_gen;
        ;
      }
      jj_consume_token(ParenClose);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

// function foo(x, ...bar)
// function foo(x, number... bar)
  final public void Function(EMethod method) throws ParseException {
 /*@bgen(jjtree) FunctionNode */
  ASTFunctionNode jjtn000 = new ASTFunctionNode(this, JJTFUNCTIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));boolean hasVarArg = false;
  boolean hasType = false;
    try {
      jj_consume_token(ParenOpen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TypeHash:
      case TypeVar:
      case TypeError:
      case TypeRegex:
      case TypeArray:
      case TypeMethod:
      case TypeString:
      case TypeNumber:
      case TypeBoolean:
      case TripleDot:
      case Var:
      case Hash:
      case Array:
      case __Error:
      case Regex:
      case Number:
      case Method:
      case String:
      case Boolean:
      case Identifier:
        hasVarArg = FunctionArgument(null);
        label_33:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Comma:
            ;
            break;
          default:
            jj_la1[118] = jj_gen;
            break label_33;
          }
            if (hasVarArg)
              {if (true) throw new ParseException(CmnCnst.Error.VAR_ARG_IN_NON_FINAL_PLACE, token);}
          jj_consume_token(Comma);
          hasVarArg = FunctionArgument(null);
        }
        break;
      default:
        jj_la1[119] = jj_gen;
        ;
      }
      jj_consume_token(ParenClose);
      jj_consume_token(LambdaArrow);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TypeHash:
      case TypeVar:
      case TypeVoid:
      case TypeError:
      case TypeRegex:
      case TypeArray:
      case TypeMethod:
      case TypeString:
      case TypeNumber:
      case TypeBoolean:
      case Var:
      case Hash:
      case Void:
      case Array:
      case __Error:
      case Regex:
      case Number:
      case Method:
      case String:
      case Boolean:
        GenericsFunction(null);
                               hasType = true;
        break;
      default:
        jj_la1[120] = jj_gen;
        ;
      }
      Block(null);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, hasVarArg, hasType);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

// i Pattern.CASE_INSENSITIVE
// m Pattern.MULTILINE
// s Pattern.DOTALL
  final public void Regex(EMethod method) throws ParseException {
 /*@bgen(jjtree) RegexNode */
  ASTRegexNode jjtn000 = new ASTRegexNode(this, JJTREGEXNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(BackslashQuotedRegex);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
    jjtn000.init(method, t.getNonnullImage());
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public void Literal(EMethod method) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BracesOpen:
    case BracketOpen:
    case TemplateLiteralOpen:
    case True:
    case Null:
    case False:
    case LogInfo:
    case LogWarn:
    case LogError:
    case LogDebug:
    case __Exception:
    case Integer:
    case Float:
    case DoubleQuotedString:
    case SingleQuotedString:
    case BackslashQuotedRegex:
      LiteralWithoutFunction(method);
      break;
    case ParenOpen:
      Function(method);
      break;
    default:
      jj_la1[121] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void LiteralWithoutFunction(EMethod method) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TemplateLiteralOpen:
    case DoubleQuotedString:
    case SingleQuotedString:
      String(method);
      break;
    case Integer:
    case Float:
      Number(method);
      break;
    case True:
    case False:
      Boolean(method);
      break;
    case BracketOpen:
      Array(method);
      break;
    case BracesOpen:
      Hash(method);
      break;
    case BackslashQuotedRegex:
      Regex(method);
      break;
    case Null:
      Null(method);
      break;
    case LogInfo:
    case LogWarn:
    case LogError:
    case LogDebug:
      Log(method);
      break;
    case __Exception:
      Exception(method);
      break;
    default:
      jj_la1[122] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_3_4() {
    if (jj_3R_35()) return true;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_scan_token(Comma)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_53() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(12)) return true;
    }
    return false;
  }

  private boolean jj_3R_65() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(3)) return true;
    }
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_37() {
    if (jj_3R_42()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_43()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(13)) return true;
    }
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_3R_59()) return true;
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_51() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(123)) {
    jj_scanpos = xsp;
    if (jj_scan_token(14)) return true;
    }
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_46() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_scan_token(ParenOpen)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_37()) jj_scanpos = xsp;
    if (jj_scan_token(ParenClose)) return true;
    if (jj_scan_token(LambdaArrow)) return true;
    xsp = jj_scanpos;
    if (jj_3R_38()) jj_scanpos = xsp;
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_62() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(1)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_65()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_66()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(2)) return true;
    }
    return false;
  }

  private boolean jj_3R_34() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_59() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(7)) {
    jj_scanpos = xsp;
    if (jj_scan_token(106)) return true;
    }
    return false;
  }

  private boolean jj_3_2() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_34()) jj_scanpos = xsp;
    if (jj_scan_token(Identifier)) return true;
    if (jj_scan_token(In)) return true;
    return false;
  }

  private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(1)) return true;
    }
    if (jj_3R_36()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(2)) return true;
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(Identifier)) return true;
    if (jj_scan_token(Colon)) return true;
    return false;
  }

  private boolean jj_3R_45() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(5)) return true;
    }
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_scan_token(TripleDot)) return true;
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) return true;
    }
    return false;
  }

  private boolean jj_3R_61() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(1)) return true;
    }
    if (jj_3R_36()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(3)) return true;
    }
    if (jj_3R_36()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(2)) return true;
    }
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_scan_token(BracesOpen)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(BracesOpen)) return true;
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_58() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(11)) return true;
    }
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_50() {
    if (jj_3R_59()) return true;
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_57() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(116)) {
    jj_scanpos = xsp;
    if (jj_scan_token(9)) return true;
    }
    return false;
  }

  private boolean jj_3R_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    }
    return false;
  }

  private boolean jj_3R_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_47()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) jj_scanpos = xsp;
    if (jj_scan_token(Identifier)) return true;
    return false;
  }

  private boolean jj_3R_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(8)) return true;
    }
    return false;
  }

  private boolean jj_3R_55() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(4)) return true;
    }
    if (jj_3R_61()) return true;
    return false;
  }

  private boolean jj_3R_38() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_66() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(6)) return true;
    }
    return false;
  }

  private boolean jj_3R_54() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(112)) {
    jj_scanpos = xsp;
    if (jj_scan_token(10)) return true;
    }
    if (jj_3R_60()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public FormExpressionParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[123];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x200000,0x600000,0x400000,0x400000,0x200000,0x7f30,0x7f30,0x7f31,0x7f30,0x7f30,0x0,0x7f30,0x7f30,0x7f30,0x7f30,0x0,0x0,0x0,0x7f30,0x0,0x0,0x7f30,0x20,0x80,0x4000,0x2000,0x1000,0x400,0x10,0x100,0x200,0x800,0x7f10,0x2,0x8,0x4,0x2,0x4,0x2,0x7fb0,0x8,0x8,0x40,0x40,0x4,0x7fb0,0x7fb0,0x0,0x7f30,0x7fb0,0x0,0x7f30,0x0,0x0,0x0,0x0,0x0,0x0,0x7f30,0x7f30,0x7f30,0x0,0x7f30,0x7f30,0x7f30,0x7f30,0x0,0x7f30,0x7f30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x28000000,0x0,0x28000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f30,0x7fb0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x16158300,0x16158300,0x16158300,0x36158300,0x36158300,0x0,0x0,0x0,0x0,0x16158300,0x0,0x0,0x4000,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x400000,0x20,0x10,0x20,0x10,0x0,0x400000,0x400000,0x0,0x0,0x20,0x0,0x0,0x400000,0x0,0x0,0x400000,0x0,0x400000,0x0,0x0,0x14158300,0x0,0x0,0x16158300,0x0,0x16158300,0x0,0x16158300,0x36158300,0x36158300,0x14158300,0x400000,0x14158300,0x14158300,0x400000,0x14158300,0x22000000,0x16158300,0x4000,0x4000,0x80,0x0,0x0,0x2000,0x1000,0x40,0x0,0x0,0x30,0x30,0x0,0x0,0x300,0x300,0x8000c00,0x8000c00,0x0,0x14158300,0x0,0x0,0x1110000,0x1110000,0x400000,0x10,0x14158300,0x400000,0x10140000,0x10000,0x40000000,0x0,0x0,0x14158300,0x0,0x10000000,0x0,0x400000,0x14358300,0x400000,0x101d0000,0x10150000,0x0,0x0,0x14158300,0x400000,0x0,0x0,0x10150000,0x10140000,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0xc0003,0xc0003,0xc0003,0xc0003,0xc0003,0x0,0x0,0x0,0x0,0xc0003,0x0,0x80000,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x10,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x10,0x0,0x0,0x0,0x3,0x0,0x0,0xc0003,0x0,0x3,0x0,0xc0003,0xc0003,0xc0003,0x3,0x0,0x3,0x3,0x0,0x3,0x0,0x3,0x3e0064ec,0x3e0064ec,0x0,0x200,0x100,0x0,0x0,0x0,0x710000,0x710000,0x1800,0x1800,0xc1800000,0xc1800000,0x0,0x0,0x0,0x0,0x8000,0x3,0x3,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x10,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x7fffbb3c,0x7fffbb3c,0x7fffbb3c,0x7fffbb3c,0x7fffbb3c,0x12040000,0xcb30210,0xcb30210,0xcb30210,0x6dfbbb3c,0x0,0x1002004,0x0,0xcb30210,0x0,0x0,0xcb30210,0x10,0x400,0x8000000,0x200000,0x4000000,0x10000,0x200,0x20000,0x100000,0x800000,0xcb30200,0x0,0x0,0x0,0x0,0x0,0x0,0xcb30610,0x0,0x0,0x0,0x0,0x0,0xcb30610,0xcb30610,0x0,0xcb30210,0xcb30610,0x0,0xcb30210,0x0,0x0,0x0,0x60080900,0x80000080,0x80000080,0x6dfbbb3c,0xcb30210,0x6cbb0b10,0x40,0x6dfbbb3c,0x6dfbbb3c,0x6dfbbb3c,0x6cbb0b10,0x0,0x6cbb0b10,0x6cbb0b10,0x0,0x60080900,0x0,0x60080900,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60080900,0x0,0x0,0x0,0x0,0x0,0x0,0x60080900,0x0,0x60080900,0x0,0x0,0x0,0x0,0x60080900,0x0,0x0,0x0,0x0,0x60080900,0x0,0x60080900,0x60080900,0x80100,0x60000000,0x60080900,0x0,0xcb30210,0xcb30610,0x60080900,0x60080900,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0xeff,0xeff,0xeff,0xeff,0xeff,0x0,0x0,0x2,0x2,0xefd,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x20,0x0,0x20,0x20,0xefc,0x0,0x0,0xefd,0x0,0xefc,0x0,0xefd,0xefd,0xefd,0xefc,0x0,0xefc,0xefc,0x0,0xefc,0x0,0xefc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xefc,0x0,0x0,0x0,0x0,0x0,0x0,0xefc,0x0,0xefc,0x0,0x0,0xc0,0x0,0xefc,0x0,0x600,0x600,0x0,0xefc,0x0,0xefc,0xefc,0x0,0xc,0xefc,0x0,0x20,0x0,0xedc,0xedc,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[4];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public FormExpressionParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public FormExpressionParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new FormExpressionParserTokenManager(this, jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 123; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 123; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public FormExpressionParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new FormExpressionParserTokenManager(this, jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 123; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 123; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public FormExpressionParser(FormExpressionParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 123; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(FormExpressionParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 123; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[140];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 123; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 140; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
