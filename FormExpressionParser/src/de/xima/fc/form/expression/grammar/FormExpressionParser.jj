/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. FormExpressionParser.jj */
/*@egen*/options {
                           
               
                            
                
                  
                  
                  
                    
                          
                          
                      
                  
                             
                       
                               

  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER  = true;
  CACHE_TOKENS = false;
  CHOICE_AMBIGUITY_CHECK = 2;
  COMMON_TOKEN_ACTION = true;
  DEBUG_LOOKAHEAD = false;
  DEBUG_PARSER = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  FORCE_LA_CHECK = false;
  GENERATE_ANNOTATIONS = true;
  GENERATE_GENERICS = true;
  GENERATE_CHAINED_EXCEPTION = false;
  GENERATE_STRING_BUILDER = false;
  GRAMMAR_ENCODING="UTF-8";
  IGNORE_CASE  = false;
  JAVA_UNICODE_ESCAPE = false;
  JDK_VERSION="1.7";
  KEEP_LINE_COLUMN = true;
  LOOKAHEAD = 1;
  OTHER_AMBIGUITY_CHECK = 1;
  UNICODE_INPUT = true;
  USER_CHAR_STREAM = false;
  USER_TOKEN_MANAGER = false;
  SANITY_CHECK = true;
  SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
  STATIC = false;
  TOKEN_MANAGER_USES_PARSER = true;
  TOKEN_EXTENDS = "";
  TOKEN_FACTORY = "";
}
PARSER_BEGIN(FormExpressionParser)
package de.xima.fc.form.expression.grammar;
import java.lang.StringBuilder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import de.xima.fc.form.expression.impl.variable.ELangObjectClass;
import de.xima.fc.form.expression.impl.variable.VoidClass;
import de.xima.fc.form.expression.enums.EMethod;
import de.xima.fc.form.expression.enums.ELogLevel;
import de.xima.fc.form.expression.enums.EVariableTypeFlag;
import de.xima.fc.form.expression.iface.parse.IComment;
import de.xima.fc.form.expression.grammar.comment.CommentFactory;
import de.xima.fc.form.expression.util.CmnCnst;
import de.xima.fc.form.expression.util.NullUtil;
import de.xima.fc.form.expression.node.*;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import com.google.common.collect.ImmutableList;

public class FormExpressionParser/*@bgen(jjtree)*/implements FormExpressionParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTFormExpressionParserState jjtree = new JJTFormExpressionParserState();

/*@egen*/
  private boolean _customLosAllowed = false;
  /** A list of all the comments occurring in the program. */
  @Nonnull private ImmutableList.Builder<IComment> _comments = new ImmutableList.Builder<IComment>();
  /** Current embedment context, or null when not in template mode. */
  @Nullable private String _currentEmbedmentContext;
  void setCurrentEmbedmentContext(String currentEmbedmentContext) {
    this._currentEmbedmentContext = currentEmbedmentContext;
  }
  void addComment(@Nonnull Token commentToken) {
    _comments.add(CommentFactory.fromToken(commentToken));
  }
  @Nullable public String getCurrentEmbedmentContext() {
    return _currentEmbedmentContext;
  }
  public void setLosAllowed(boolean losAllowed) {
    this._customLosAllowed = losAllowed;
  }
  @Nonnull public ImmutableList<IComment> buildComments() {
    return _comments.build();
  }
}
PARSER_END(FormExpressionParser)

/*
We use a counter and a stack to keep track of nested template literals and
inline expressions. The following example illustrates this. Consider the
following code:

  1+2;
  `Some literal words ${{foo:`${}`}}, I hope.`;

Step by step, this shows the values of the counter and step at each token:

 <beg>[]    code        (start out in mode code)
 ...
 `  0 []    ->template  (` switches to mode template)
 ...
 ${ 1 [0]   ->code      (syntax for inline expressions, switch to mode code)
 {  2 [0]   code        (in mode code, this is the syntax for a hash literal)
 ...
 `  2 [0]   ->template  (we are in mode code, so this starts another template literal)
 ${ 3 [0,2] ->code      (start another inline expression)
 }  2 [0]   ->template  (2 is on the stack, so go back to template literal)
 `  2 [0]   ->code      (we are in mode template, so this ends it)
 }  1 [0]   code        (1 is not on top of the stack, so we stay in mode code)
 }  0 []    ->template  (0 is on top of the stack, so we go back to template literal)
 ...
 `  0 []    ->code      (we are in mode template, so this ends it)
*/
TOKEN_MGR_DECLS :
{
  private int typeLevel = 0;
  private Token lastToken;
  private int countBraces = 0;
  private int[] stackTemplateLiteral = new int[4];
  private int posTemplateLiteral = -1;
  void CommonTokenAction(final Token token) {
    // Retrieve all comments, if there are any.
    lastToken = token;
    if (parser == null) return;
    Token special = token;
    if (token.specialToken != null) {
      while (special.specialToken != null) special = special.specialToken;
      while (special != null) {
        parser.addComment(special);
        special = special.next;
      }
    }
  }
  void pushTemplateLiteral() {
    if (posTemplateLiteral + 1 >= stackTemplateLiteral.length)
      stackTemplateLiteral = Arrays.copyOf(stackTemplateLiteral, 2*(posTemplateLiteral+2));
    stackTemplateLiteral[++posTemplateLiteral] = countBraces;
  }
  
  void popTemplateLiteralIfMatching() {
    if (posTemplateLiteral >= 0 && stackTemplateLiteral[posTemplateLiteral] == countBraces) {
      SwitchTo(FormExpressionParserConstants.TEMPLATE_LITERAL);
      --posTemplateLiteral;
    }
  }
}

< TYPE >
TOKEN :
{
  < TypeAngleOpen : "<" > { ++typeLevel;}
| < TypeAngleClose : ">" > { --typeLevel; if (typeLevel == 0) SwitchTo(FormExpressionParserConstants.CODE); }
| < TypeComma : "," >
| < TypeHash : "hash" >
| < TypeVar : "var" >
| < TypeTripleDot : "..." >
| < TypeVoid : "void" >
| < TypeError : "error" >
| < TypeRegex : "regex" >
| < TypeArray : "array" >
| < TypeMethod : "method" >
| < TypeString : "string" >
| < TypeNumber : "number" >
| < TypeBoolean : "boolean" >
}

< TYPE >
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

< TYPE >
SPECIAL_TOKEN:
{ 
  < TypeSingleLineComment: "//" (~["\n"])* ("\n")?>
}

< TYPE >
MORE:
{ 
  < "/*" > : TYPE_MULTI_LINE_COMMENT
}

< LOS >
TOKEN :
{
  < LosOpen : "[%" ([ "%", "$", "@", "=" ])* >
  {
    if (parser != null) parser.setCurrentEmbedmentContext(matchedToken.image);
  }
  : CODE
| 
  < LosChar : ~[ ] >
}

< TYPE_MULTI_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < TypeMultiLineComment: "*/" > : TYPE
}

< TYPE_MULTI_LINE_COMMENT >
MORE :
{
  < ~[ ] >
}


< MULTI_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < MultiLineComment: "*/" > : CODE
}

< MULTI_LINE_COMMENT >
MORE :
{
  < ~[ ] >
}

< TEMPLATE_LITERAL >
TOKEN:
{
  < TemplateLiteralInlineOpen : "${" > {
    pushTemplateLiteral();
    ++countBraces;
  } : CODE
| < TemplateLiteralClose : "`" >
  : CODE
| < TemplateLiteralChars :
    (
      ("\\" ~[ ])
    | ~[ "$", "\\", "`" ]
    )+ >
}

< CODE >
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

< CODE >
MORE:
{ 
  < "/*" > : MULTI_LINE_COMMENT
}

< CODE >
SPECIAL_TOKEN:
{ 
  < SingleLineComment: "//" (~["\n"])* ("\n")?>
}

< CODE >
TOKEN :
{
  < AngleOpen : "<" > {
    if (lastToken != null && lastToken.kind == FormExpressionParserConstants.Function) {
      typeLevel = 1;
      SwitchTo(FormExpressionParserConstants.TYPE);
    }
  }
|
  < AngleClose : ">" >
|
  < Ampersand : "&" >
|
  < QuestionMark : "?" >
|
  < Plus : "+" >
|
  < Dash : "-" >
|
  < Star : "*" >
|
  < Slash : "/" >
|
  < Circumflex : "^" >
|
  < Bar : "|" >
| 
  < Equal : "=" >
| 
  < Tilde : "~" >
| 
  < ParenOpen : "(" >
| 
  < ParenClose : ")" >
|
  < BracesOpen : "{" > {
    ++countBraces;
  }
|
  < BracesClose : "}" > {
    --countBraces;
    popTemplateLiteralIfMatching();
  }
|
  < BracketOpen : "[" >
|
  < BracketClose : "]" >
|
  < Comma : "," >
|
  < Colon : ":" >
|
  < Dot : "." >
|
  < SemiColon : ";" >
|
  < Exclamation : "!" >
|
  < Percent : "%" >
|
  < TemplateLiteralOpen : "`"> : TEMPLATE_LITERAL
|
  < LosBodyClose : "%]" > : LOS
|
  < ScopeSeparator : "::" >
|
  < LambdaArrow : "=>" >
|
  < DoublePlus : "++" >
|
  < DoubleDash : "--" >
|
  < PlusEqual : "+=" >
|
  < DashEqual : "-=" >
|
  < TripleDot : "..." >
|
  < StarEqual : "*=" >
|
  < SlashEqual : "/=" >
|
  < PercentEqual : "%=" >
|
  < DoubleAmpersand : "&&" >
|
  < DoubleBar : "||" >
|
  < AmpersandEqual : "&=" >
|
  < AngleOpenEqual : "<=" >
|
  < AngleCloseEqual : ">=" >
|
  < BarEqual : "|=" >
|
  < CircumflexEqual : "^=" >
|
  < DoubleStar : "**" >
| 
  < DoubleEqual : "==" >
| 
  < In : "in" >
| 
  < If : "if" >
| 
  < Do : "do" >
| 
  < ExclamationEqual : "!=" >
| 
  < EqualTilde : "=~" >
|
  < ExclamationTilde : "!~" >
|
  < DoubleAngleOpen : "<<" > 
|
  < DoubleAngleClose : ">>" > 
| 
  < DoubleStarEqual : "**=" >
| 
  < DoubleAngleOpenEqual : "<<=" >
| 
  < DoubleAngleCloseEqual : ">>=" >
| 
  < TripleAngleOpenEqual : "<<<=" >
| 
  < TripleAngleCloseEqual : ">>>=" >
|
  < TripleAngleOpen : ">>>" >
|
  < TripleAngleClose : "<<<" >
| 
  < TripleEqual : "===" >
| 
  < ExclamationDoubleEqual : "!==" >
| 
  < For : "for" >
| 
  < Try : "try" >
| 
  < Var : "var" >
|
  < With : "with" >
| 
  < Else : "else" >
| 
  < Case : "case" >
|
  < True : "true" >
| 
  < Hash : "hash" > { typeLevel = 0; } : TYPE
| 
  < Void : "void" >
| 
  < Null : "null" >
| 
  < Break : "break" >
| 
  < While : "while" >
| 
  < Catch : "catch" >
| 
  < Throw : "throw" >
| 
  < Array : "array" > { typeLevel = 0; } : TYPE
| 
  < __Error : "error" >
| 
  < Scope : "scope" >
| 
  < False : "false" >
| 
  < Regex : "regex" >
| 
  < Number : "number" >
| 
  < Return : "return" >
| 
  < Method : "method" > { typeLevel = 0; } : TYPE
| 
  < Switch : "switch" >
| 
  < Global : "global" >
| 
  < String : "string" >
| 
  < Boolean : "boolean" >
| 
  < Require : "require" >
| 
  < LogInfo : "loginfo" >
| 
  < LogWarn : "logwarn" >
| 
  < Default : "default" >
| 
  < Continue : "continue" >
| 
  < Function : "function" >
| 
  < LogError : "logerror" >
| 
  < LogDebug : "logdebug" >
|
  < __Exception : "exception" >
| 
  < Identifier : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "_", "0"-"9" ])* >
| 
  < Integer : ([ "0"-"9" ])+ >
| 
  < Float :
    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< EXPONENT >)?
  | "." ([ "0"-"9" ])+ (< EXPONENT >)?
  | ([ "0"-"9" ])+ < EXPONENT > 
  >
| 
  < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >
| 
  < DoubleQuotedString :
    "\""
    (
      ("\\" ~[ ])
    | ~[ "\\", "\"" ]
    )*
    "\"" >
| 
  < SingleQuotedString :
    "'"
    (
      ("\\" ~[ ])
    | ~[ "\\", "'" ]
    )*
    "'" >
|
  < BackslashQuotedRegex :
    "#"
    (
      ("\\" ~[ ])
    | ~[ "\\", "#" ]
    )*
    "#"
    ([ "i", "m", "s" ])* >
}

Node Template(EMethod method)                    :
{/*@bgen(jjtree) StatementListNode */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) StatementListNode */
  try {
/*@egen*/
  (
    (
      (
        LosChars(null)
        [
          LosOpen(null) TemplateProgram(null)
        ]
      )
    | 
      (        LosOpen(null) TemplateProgram(null)
      )
    )
    < EOF >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (token_source.curLexState == FormExpressionParserConstants.CODE)
      throw new ParseException(CmnCnst.Error.FINAL_CODE_BLOCK_NOT_CLOSED, token);
    jjtn000.init(method);
    
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

/* Los = Literal Output Statement */
void LosChars(EMethod method)          :
{/*@bgen(jjtree) LosNode */
  ASTLosNode jjtn000 = new ASTLosNode(this, JJTLOSNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
  final StringBuilder sb = new StringBuilder();
  
}
{/*@bgen(jjtree) LosNode */
  try {
/*@egen*/
  (
    (
      t = < LosChar >
      {
        sb.append(t.getNonnullImage().charAt(0));
      }
    )+
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, sb.toString(), null, false);
    
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void LosOpen(EMethod method)          :
{/*@bgen(jjtree) LosNode */
  ASTLosNode jjtn000 = new ASTLosNode(this, JJTLOSNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
  
}
{/*@bgen(jjtree) LosNode */
  try {
/*@egen*/
  (
    t = < LosOpen >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (!_customLosAllowed) throw new ParseException(
      NullUtil.messageFormat(CmnCnst.Error.EMBEDDED_BLOCK_NOT_ALLOWED), token);
    jjtn000.init(method, CmnCnst.NonnullConstant.STRING_EMPTY, t.getNonnullImage(), false);    
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}


void LosBody(EMethod method)          :
{/*@bgen(jjtree) LosNode */
  ASTLosNode jjtn000 = new ASTLosNode(this, JJTLOSNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t = null;
  Token p = null;
  final StringBuilder sb = new StringBuilder();
  
}
{/*@bgen(jjtree) LosNode */
  try {
/*@egen*/
  (
    < LosBodyClose >
    (
      t = < LosChar >
      {
        sb.append(t.getNonnullImage().charAt(0));
      }
    )*
    [ p = < LosOpen > ]
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (!_customLosAllowed) throw new ParseException(
      NullUtil.messageFormat(CmnCnst.Error.EMBEDDED_BLOCK_NOT_ALLOWED), token);
    jjtn000.init(method, sb.toString(), p != null ? p.image : null, true);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

Node CompleteProgram(EMethod method)                    :
{/*@bgen(jjtree) StatementListNode */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) StatementListNode */
  try {
/*@egen*/
  (
    (
      (
        ClauseOrStatement(null)
      | ScopeDefinition(null)
      | FunctionClauseWithOptionalScope(null)
      )+
      < EOF >
    )
  | < EOF >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
    
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void TemplateProgram(EMethod method)                    :
{/*@bgen(jjtree) StatementListNode */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) StatementListNode */
  try {
/*@egen*/
  (
    (
      ClauseOrStatement(null)
    | ScopeDefinition(null)
    | FunctionClauseWithOptionalScope(null)
    | LosBody(null)
    )+
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
    
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ScopeDefinition(EMethod method)       :
{
}
{
  (      ScopeExternal(method)
    | ScopeGlobal(method)
    | ScopeManual(method)
  )
}

void ScopeGlobal(EMethod method)                  :
{/*@bgen(jjtree) ScopeGlobalNode */
  ASTScopeGlobalNode jjtn000 = new ASTScopeGlobalNode(this, JJTSCOPEGLOBALNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) ScopeGlobalNode */
  try {
/*@egen*/
  (
    < Global > < Scope > < BracesOpen >
    (
      VariableDeclarationClause(null)
    )*
    < BracesClose >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ScopeManual(EMethod method)                  :
{/*@bgen(jjtree) ScopeManualNode */
  ASTScopeManualNode jjtn000 = new ASTScopeManualNode(this, JJTSCOPEMANUALNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) ScopeManualNode */
  try {
/*@egen*/
  (
    < Scope > t = < Identifier > < BracesOpen >
    (
      VariableDeclarationClause(null)
    | FunctionClause(null)
    )*
    < BracesClose >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, t.getNonnullImage());
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ScopeExternal(EMethod method)                    :
{/*@bgen(jjtree) ScopeExternalNode */
  ASTScopeExternalNode jjtn000 = new ASTScopeExternalNode(this, JJTSCOPEEXTERNALNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) ScopeExternalNode */
  try {
/*@egen*/
  (
  < Require > < Scope > t = < Identifier > < SemiColon >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, t.getNonnullImage());
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ClauseOrStatement(EMethod method)       :
{
}
{
  (
    LOOKAHEAD(< Identifier > < Colon >)
    LabeledClause(method)
  | ForLoop(method, null)
  | WhileLoop(method, null)
  | DoWhileLoop(method, null)
  | SwitchClause(method, null)
  | IfClause(method)
  | TryClause(method)
  | WithClause(method)
  | ThrowClause(method)
  | BreakClause(method)
  | ContinueClause(method)
  | ReturnClause(method)
  | VariableDeclarationClause(method)
  | Statement(method)
  )
}


void LabeledClause(EMethod method)       :
{
  Token t = null;
}
{
  [ t = < Identifier > < Colon > ]
  (
    ForLoop(method, t)
  | WhileLoop(method, t)
  | DoWhileLoop(method, t)
  | SwitchClause(method, t)
  )
}

void VariableDeclarationClauseWithoutAssignment(EMethod method)                                :
{/*@bgen(jjtree) VariableDeclarationClauseNode */
  ASTVariableDeclarationClauseNode jjtn000 = new ASTVariableDeclarationClauseNode(this, JJTVARIABLEDECLARATIONCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) VariableDeclarationClauseNode */
  try {
/*@egen*/
  (
      VariableType(null)    
      t = < Identifier > < SemiColon >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, t.getNonnullImage());
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void VariableDeclarationClause(EMethod method)                                :
{/*@bgen(jjtree) VariableDeclarationClauseNode */
  ASTVariableDeclarationClauseNode jjtn000 = new ASTVariableDeclarationClauseNode(this, JJTVARIABLEDECLARATIONCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) VariableDeclarationClauseNode */
  try {
/*@egen*/
  (
      VariableType(null)    
      t = < Identifier > [ < Equal > Expression(null) ] < SemiColon >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, t.getNonnullImage());
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

boolean FunctionArgument(EMethod method)                       :
{/*@bgen(jjtree) FunctionArgumentNode */
  ASTFunctionArgumentNode jjtn000 = new ASTFunctionArgumentNode(this, JJTFUNCTIONARGUMENTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
  boolean hasVarArg = false;
}
{/*@bgen(jjtree) FunctionArgumentNode */
  try {
/*@egen*/
  (
      [ VariableType(null) ] [ <TripleDot > { hasVarArg = true; }] t = < Identifier >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, t.getNonnullImage());
    return hasVarArg;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void VariableDeclarationExpressionWithAssignment(EMethod method)                                :
{/*@bgen(jjtree) VariableDeclarationClauseNode */
  ASTVariableDeclarationClauseNode jjtn000 = new ASTVariableDeclarationClauseNode(this, JJTVARIABLEDECLARATIONCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) VariableDeclarationClauseNode */
  try {
/*@egen*/
  (
      VariableType(null) t = < Identifier > [ < Equal > Expression(null) ]
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, t.getNonnullImage());
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void VariableType(EMethod method)       :
{
}
{
  (
    UnspecificVariableType(method) | SpecificVariableType(method)
  )
}

void UnspecificVariableType(EMethod method)                   :
{/*@bgen(jjtree) VariableTypeNode */
  ASTVariableTypeNode jjtn000 = new ASTVariableTypeNode(this, JJTVARIABLETYPENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) VariableTypeNode */
  try {
/*@egen*/
  (
    < Var > | < TypeVar >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, ELangObjectClass.OBJECT);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void VoidVariableType(EMethod method)                   :
{/*@bgen(jjtree) VariableTypeNode */
  ASTVariableTypeNode jjtn000 = new ASTVariableTypeNode(this, JJTVARIABLETYPENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) VariableTypeNode */
  try {
/*@egen*/
  (
    < TypeVoid > | < Void >  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, VoidClass.INSTANCE);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void SpecificVariableType(EMethod method)                   :
{/*@bgen(jjtree) VariableTypeNode */
  ASTVariableTypeNode jjtn000 = new ASTVariableTypeNode(this, JJTVARIABLETYPENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  ELangObjectClass type;
  EVariableTypeFlag flag = null;
}
{/*@bgen(jjtree) VariableTypeNode */
  try {
/*@egen*/
  (
    ( < Boolean >  | < TypeBoolean > )
    {
      type = ELangObjectClass.BOOLEAN;
    }
  | (< Number > | < TypeNumber >)
    {
      type = ELangObjectClass.NUMBER;
    }
  | (< String >  | < TypeString >)
    {
      type = ELangObjectClass.STRING;
    }
  |
    (
      ( < Array > | < TypeArray > )
      GenericsArray(null)
      {
        type = ELangObjectClass.ARRAY;
      }
    )
  |
    (
      ( < Hash > | < TypeHash > )
      GenericsHash(null)
      {
        type = ELangObjectClass.HASH;
      }
    )
  | ( < __Error > | < TypeError > )
    {
      type = ELangObjectClass.EXCEPTION;
    }
  | ( < Regex > | < TypeRegex > )
    {
      type = ELangObjectClass.REGEX;
    }
  |
    (
      ( < Method >  | < TypeMethod > )
      flag = GenericsMethod(null)
      {
        type = ELangObjectClass.FUNCTION;
      }
    )
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, type, flag);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void GenericsHash(EMethod method)      :
{
}
{
  (
    < AngleOpen >
  | < TypeAngleOpen >
  )
  VariableType(method)
  (
    < Comma >
  | < TypeComma >
  )
  VariableType(method)
  (
    < AngleClose >
  | < TypeAngleClose >
  )
}

void GenericsArray(EMethod method)      :
{
}
{
  (
    < AngleOpen >
  | < TypeAngleOpen >
  )
  VariableType(method)
  (
    < AngleClose >
  | < TypeAngleClose >
  )
}

EVariableTypeFlag GenericsMethod(EMethod method)      :
{
  EVariableTypeFlag flag = null;
}
{
  (
    (
      < AngleOpen >
    | < TypeAngleOpen >
    )
    (
      VariableType(method)
    | VoidVariableType(method)
    )
    (
      (
        < Comma >
      | < TypeComma >
      )
      VariableType(method)
    )*
    [
      (
        < TripleDot >
      | < TypeTripleDot >
      )
      {
        flag = EVariableTypeFlag.VARARG;
      }
    ]
    (
      < AngleClose >
    | < TypeAngleClose >
    )
  )
  {
    return flag;
  }
}

void GenericsFunction(EMethod method)       :
{
}
{
  (
    VariableType(method)
  | VoidVariableType(method)
  )
}

void FunctionClauseWithOptionalScope(EMethod method)                     :
{/*@bgen(jjtree) FunctionClauseNode */
  ASTFunctionClauseNode jjtn000 = new ASTFunctionClauseNode(this, JJTFUNCTIONCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
  boolean hasVarArg = false;
  boolean hasType = false;
}
{/*@bgen(jjtree) FunctionClauseNode */
  try {
/*@egen*/
  (
    < Function >
    [ GenericsFunction(null) { hasType = true; } ]
    VariableWithOptionalScope(null)
    < ParenOpen >
    (
      [
        hasVarArg = FunctionArgument(null)
        (
          {
            if (hasVarArg)
              throw new ParseException(CmnCnst.Error.VAR_ARG_IN_NON_FINAL_PLACE, token);
          }
          (            < Comma > hasVarArg = FunctionArgument(null)
          )
        )*
      ]
    )
    < ParenClose >
    (
      Block(null)
    )
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, hasVarArg, hasType);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void FunctionClause(EMethod method)                     :
{/*@bgen(jjtree) FunctionClauseNode */
  ASTFunctionClauseNode jjtn000 = new ASTFunctionClauseNode(this, JJTFUNCTIONCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
  boolean hasVarArg = false;
  boolean hasType = false;
}
{/*@bgen(jjtree) FunctionClauseNode */
  try {
/*@egen*/
  (
    < Function >
    [ GenericsFunction(null) { hasType = true; } ]
    Variable(null)
    < ParenOpen >
    (
      [
        hasVarArg = FunctionArgument(null)
        (
          {
            if (hasVarArg)
              throw new ParseException(CmnCnst.Error.VAR_ARG_IN_NON_FINAL_PLACE, token);
          }
          (
            < Comma > hasVarArg = FunctionArgument(null)
          )
        )*
      ]
    )
    < ParenClose >
    (
      Block(null)
    )
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, hasVarArg, hasType);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void WithClause(EMethod method)                 :
{/*@bgen(jjtree) WithClauseNode */
  ASTWithClauseNode jjtn000 = new ASTWithClauseNode(this, JJTWITHCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  
}
{/*@bgen(jjtree) WithClauseNode */
  try {
/*@egen*/
  (
    < With > < ParenOpen > IdentifierName(null)
    (
      < Comma > IdentifierName(null)
    )*
    < ParenClose > BlockOrClause(null)
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
    
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ContinueClause(EMethod method)                     :
{/*@bgen(jjtree) ContinueClauseNode */
  ASTContinueClauseNode jjtn000 = new ASTContinueClauseNode(this, JJTCONTINUECLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t = null;
}
{/*@bgen(jjtree) ContinueClauseNode */
  try {
/*@egen*/
  (
  < Continue > [ t = < Identifier > ] < SemiColon >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, t == null ? null : t.getNonnullImage());
    
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void BreakClause(EMethod method)                  :
{/*@bgen(jjtree) BreakClauseNode */
  ASTBreakClauseNode jjtn000 = new ASTBreakClauseNode(this, JJTBREAKCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t = null;
  
}
{/*@bgen(jjtree) BreakClauseNode */
  try {
/*@egen*/
  (
  < Break > [ t = < Identifier > ] < SemiColon >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, t == null ? null : t.getNonnullImage());
    
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ReturnClause(EMethod method)                   :
{/*@bgen(jjtree) ReturnClauseNode */
  ASTReturnClauseNode jjtn000 = new ASTReturnClauseNode(this, JJTRETURNCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  
}
{/*@bgen(jjtree) ReturnClauseNode */
  try {
/*@egen*/
  (
    < Return > [ Expression(null) ] < SemiColon >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
    
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ThrowClause(EMethod method)                  :
{/*@bgen(jjtree) ThrowClauseNode */
  ASTThrowClauseNode jjtn000 = new ASTThrowClauseNode(this, JJTTHROWCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  
}
{/*@bgen(jjtree) ThrowClauseNode */
  try {
/*@egen*/
  (
    < Throw > Expression(null) < SemiColon >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
    
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void SwitchClause(EMethod method, Token label)                   :
{/*@bgen(jjtree) SwitchClauseNode */
  ASTSwitchClauseNode jjtn000 = new ASTSwitchClauseNode(this, JJTSWITCHCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  EMethod switchMethod = EMethod.SWITCHCLAUSE;
  int indexDefault = -1;
}
{/*@bgen(jjtree) SwitchClauseNode */
  try {
/*@egen*/
  (
    < Switch > < ParenOpen > Expression(null) < ParenClose > < BracesOpen >
    indexDefault = SwitchBlockStatementGroup()
    < BracesClose >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, label != null ? label.image : null, indexDefault);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

int SwitchBlockStatementGroup()       :
{
  Token lastDefault = null;
  EMethod switchMethod;
  int index = 0;
  int indexDefault =-1;
}
{
  (
    (
      (
        (
          (
            < Case > Expression(EMethod.SWITCHCASE) < Colon >
          )
          {
            if (lastDefault != null)
				throw new ParseException(CmnCnst.Error.DEFAULT_CASE_MUST_BE_LAST, lastDefault);
            switchMethod = EMethod.SWITCHCLAUSE;
            ++index;
          }
        )
      | lastDefault = < Default > < Colon >
        {
          if (indexDefault != - 1) 
          throw new ParseException(CmnCnst.Error.DEFAULT_USED_MULTIPLE_TIMES, token);
          indexDefault = index;
          switchMethod = EMethod.SWITCHDEFAULT;
          ++index;
        }
      )
      (
        ClauseOrStatement(switchMethod)
      )*
    )*
  )
  {
    return indexDefault;
  }
}

/*
void SwitchClause(EMethod method, Token label) #SwitchClauseNode :
{
}
{
  (
    < Switch > < ParenOpen > Expression(null) < ParenClose > < BracesOpen >
    (
      SwitchCase()
    )*
    [SwitchDefault() ] 
    < BracesClose >
  )
  {
    jjtThis.init(method, label != null ? label.image : null);
  }
}

void SwitchCase() #void :
{
}
{
  (
    (
      < Case > Expression(EMethod.SWITCHCASE) < Colon >
    )+
    (
      ClauseOrStatement(EMethod.SWITCHCLAUSE)
    )+
  )
}
*/

/*
void SwitchDefault() #void :
{
}
{
  (
    < Default > < Colon >
    (
      ClauseOrStatement(EMethod.SWITCHDEFAULT)
    )+
  )
}
*/

void TryClause(EMethod method)                :
{/*@bgen(jjtree) TryClauseNode */
  ASTTryClauseNode jjtn000 = new ASTTryClauseNode(this, JJTTRYCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) TryClauseNode */
  try {
/*@egen*/
  (
    < Try >
    (
      Block(null)
    )
    < Catch > < ParenOpen > t = < Identifier > < ParenClose >
    (
      Block(null)
    )
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, t.getNonnullImage());
    
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void DoWhileLoop(EMethod method, Token label)                  :
{/*@bgen(jjtree) DoWhileLoopNode */
  ASTDoWhileLoopNode jjtn000 = new ASTDoWhileLoopNode(this, JJTDOWHILELOOPNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) DoWhileLoopNode */
  try {
/*@egen*/
  (
    < Do >
    BlockOrClause(null) 
    < While > < ParenOpen > Expression(null) < ParenClose > < SemiColon >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, label != null ? label.image : null);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void WhileLoop(EMethod method, Token label)                :
{/*@bgen(jjtree) WhileLoopNode */
  ASTWhileLoopNode jjtn000 = new ASTWhileLoopNode(this, JJTWHILELOOPNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) WhileLoopNode */
  try {
/*@egen*/
  (
    < While > < ParenOpen > Expression(null) < ParenClose > 
    BlockOrClause(null)
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, label != null ? label.image : null);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ForLoop(EMethod method, Token label)              :
{/*@bgen(jjtree) ForLoopNode */
  ASTForLoopNode jjtn000 = new ASTForLoopNode(this, JJTFORLOOPNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token iteratingLoopVariable = null;
  boolean hasType = false;
}
{/*@bgen(jjtree) ForLoopNode */
  try {
/*@egen*/
  (
    < For > < ParenOpen >
    (
      // When we encounter the "in" keyword, we know it must
      // be an enhanced loop, as it is used only here.
      // Otherwise, it must be a plain loop.
      LOOKAHEAD([ VariableType(null) ] < Identifier > < In >)
      (
        [ VariableType(null) { hasType = true; } ]
        iteratingLoopVariable = < Identifier >
        < In >
        Expression(null)
      )
    |
      (
        ExpressionOrVariableDeclarationListCommaSeparated(null)
        < SemiColon >
        ExpressionListCommaSeparated(null)
        < SemiColon >
        ExpressionListCommaSeparated(null)
      )
    )
    < ParenClose > 
    BlockOrClause(null)
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method,
      iteratingLoopVariable != null ? iteratingLoopVariable.image : null,
      label != null ? label.image : null,
      hasType);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

// A dangling else binds to the closest if, which
// is what the default algorithm with a lookahead
// of 1 does.
void IfClause(EMethod method)               :
{/*@bgen(jjtree) IfClauseNode */
  ASTIfClauseNode jjtn000 = new ASTIfClauseNode(this, JJTIFCLAUSENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/  
}
{/*@bgen(jjtree) IfClauseNode */
  try {
/*@egen*/
  (
    < If > 
    < ParenOpen > Expression(null) < ParenClose > 
    BlockOrClause(null)
    [
      LOOKAHEAD(1)
      < Else > 
      BlockOrClause(null)
    ]
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

// An opening brace might indicate either the begining of a
// block or the beginning of a hash. In order to avoid too
// much lookahead, the parser commits to it being a block
// when it sees an opening brace. If you want a hash literal,
// put it inside a block like this:
//    if (true) {
//        { foo: "bar" };
//    }
//
void BlockOrClause(EMethod method)       :
{
}
{
  LOOKAHEAD(< BracesOpen >)
  Block(method)
| ClauseOrStatement(method)
}

void Block(EMethod method)                                                          :
{/*@bgen(jjtree) #StatementListNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode;
}
{/*@bgen(jjtree) #StatementListNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    < BracesOpen >
    (
      (
        ClauseOrStatement(null)
      | LosBody(null)
      )*
    )
    < BracesClose >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) {
      jjtn000.init(method);
    }
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ExpressionOrVariableDeclarationListCommaSeparated(EMethod method)                    :
{/*@bgen(jjtree) StatementListNode */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  
}
{/*@bgen(jjtree) StatementListNode */
  try {
/*@egen*/
  (
    [
      (
        VariableDeclarationExpressionWithAssignment(null)
      | Expression(null)
      )
      (
        < Comma >
        (
          Expression(null)
        | VariableDeclarationExpressionWithAssignment(null)
        )
      )*
    ]
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
    
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}


void ExpressionListCommaSeparated(EMethod method)                    :
{/*@bgen(jjtree) StatementListNode */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  
}
{/*@bgen(jjtree) StatementListNode */
  try {
/*@egen*/
  (
    [
      Expression(null)
      (
        < Comma > Expression(null)
      )*
    ]
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
    
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Statement(EMethod method)                                                          :
{/*@bgen(jjtree) #StatementListNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTStatementListNode jjtn000 = new ASTStatementListNode(this, JJTSTATEMENTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode;
}
{/*@bgen(jjtree) #StatementListNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    (
      (Expression(method) (< SemiColon > | LosBody(null)))
    )
  | EmptyStatement(method)
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) { 
      jjtn000.init(method);
      
    }
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

Node EmptyStatement(EMethod method)            :
{/*@bgen(jjtree) EmptyNode */
  ASTEmptyNode jjtn000 = new ASTEmptyNode(this, JJTEMPTYNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) EmptyNode */
  try {
/*@egen*/
  (
  < SemiColon >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
    
    return jjtn000;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Expression(EMethod method)       :
{
}
{
  EqualTypeExpression(method)
}

void EqualTypeExpression(EMethod method)                                                                 :
{/*@bgen(jjtree) #AssignmentExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTAssignmentExpressionNode jjtn000 = new ASTAssignmentExpressionNode(this, JJTASSIGNMENTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode;
}
{/*@bgen(jjtree) #AssignmentExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    TernaryExpression(method)
    (
      (
        < Equal >
        TernaryExpression(EMethod.EQUAL)
      )
    |
      (
        < PlusEqual > TernaryExpression(EMethod.PLUS_EQUAL)
      )
    |
      (
        < DashEqual > TernaryExpression(EMethod.DASH_EQUAL)
      )
    |
      (
        < DoubleStarEqual > TernaryExpression(EMethod.DOUBLE_STAR_EQUAL)
      )
    |
      (
        < StarEqual > TernaryExpression(EMethod.STAR_EQUAL)
      )
    |
      (
        < SlashEqual > TernaryExpression(EMethod.SLASH_EQUAL)
      )
    |
      (
        < PercentEqual > TernaryExpression(EMethod.PERCENT_EQUAL)
      )
    |
      (
        < DoubleAngleOpenEqual > TernaryExpression(EMethod.DOUBLE_ANGLE_OPEN_EQUAL)
      )
    |
      (
        < DoubleAngleCloseEqual > TernaryExpression(EMethod.DOUBLE_ANGLE_CLOSE_EQUAL)
      )
    |
      (
        < TripleAngleOpenEqual > TernaryExpression(EMethod.TRIPLE_ANGLE_OPEN_EQUAL)
      )
    |
      (
        < TripleAngleCloseEqual > TernaryExpression(EMethod.TRIPLE_ANGLE_CLOSE_EQUAL)
      )
    |
      (
        < AmpersandEqual > TernaryExpression(EMethod.AMPERSAND_EQUAL)
      )
    |
      (
        < CircumflexEqual > TernaryExpression(EMethod.CIRCUMFLEX_EQUAL)
      )
    |
      (
        < BarEqual > TernaryExpression(EMethod.BAR_EQUAL)
      )
    )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) jjtn000.init(method);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void TernaryExpression(EMethod method)                                                              :
{/*@bgen(jjtree) #TernaryExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTTernaryExpressionNode jjtn000 = new ASTTernaryExpressionNode(this, JJTTERNARYEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode; 
}
{/*@bgen(jjtree) #TernaryExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    DoubleBarExpression(method)
    [
      < QuestionMark > DoubleBarExpression(method) < Colon > DoubleBarExpression(method)
    ]
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) jjtn000.init(method);    
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void DoubleBarExpression(EMethod method)                                                       :
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode; 
}
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    DoubleAmpersandExpression(method)
    (
      < DoubleBar >
      DoubleAmpersandExpression(EMethod.DOUBLE_BAR)
    )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) jjtn000.init(method);   
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void DoubleAmpersandExpression(EMethod method)                                                       :
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode;
  
}
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    BarExpression(method)
    (
      < DoubleAmpersand >
      BarExpression(EMethod.DOUBLE_AMPERSAND)
    )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) jjtn000.init(method);
    
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void BarExpression(EMethod method)                                                       :
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode;
  
}
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    CircumflexExpression(method)
    (
      < Bar >
      CircumflexExpression(EMethod.BAR)
    )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) jjtn000.init(method);
    
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void CircumflexExpression(EMethod method)                                                       :
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode;
  
}
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    AmpersandExpression(method)
    (
      < Circumflex >
      AmpersandExpression(EMethod.CIRCUMFLEX)
    )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) jjtn000.init(method);
    
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void AmpersandExpression(EMethod method)                                                       :
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode;
  
}
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    DoubleEqualTypeExpression(method)
    (
      < Ampersand >
      DoubleEqualTypeExpression(EMethod.AMPERSAND)
    )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) jjtn000.init(method); 
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void DoubleEqualTypeExpression(EMethod method)                                                            :
{/*@bgen(jjtree) #EqualExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTEqualExpressionNode jjtn000 = new ASTEqualExpressionNode(this, JJTEQUALEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode;
}
{/*@bgen(jjtree) #EqualExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    AngleTypeExpression(method)
    (
      (
        < ExclamationTilde >
        AngleTypeExpression(EMethod.EXCLAMATION_TILDE)
      )
    |
      (
        < EqualTilde >
        AngleTypeExpression(EMethod.EQUAL_TILDE)
      )
    |
      (
        < TripleEqual >
        AngleTypeExpression(EMethod.TRIPLE_EQUAL)
      )
    |
      (
        < DoubleEqual >
        AngleTypeExpression(EMethod.DOUBLE_EQUAL)
      )
    |
      (
        < ExclamationDoubleEqual >
        AngleTypeExpression(EMethod.EXCLAMATION_DOUBLE_EQUAL)
      )
    |
      (
        < ExclamationEqual >
        AngleTypeExpression(EMethod.EXCLAMATION_EQUAL)
      )
    )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) {
      
      jjtn000.init(method);
    }
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void AngleTypeExpression(EMethod method)                                                                 :
{/*@bgen(jjtree) #ComparisonExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTComparisonExpressionNode jjtn000 = new ASTComparisonExpressionNode(this, JJTCOMPARISONEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode;
}
{/*@bgen(jjtree) #ComparisonExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    MultiAngleExpression(method)
    (
      (
        < AngleOpen > MultiAngleExpression(EMethod.ANGLE_OPEN)
      )
    |
      (
        < AngleClose > MultiAngleExpression(EMethod.ANGLE_CLOSE)
      )
    |
      (
        < AngleOpenEqual > MultiAngleExpression(EMethod.ANGLE_OPEN_EQUAL)
      )
    |
      (
        < AngleCloseEqual > MultiAngleExpression(EMethod.ANGLE_CLOSE_EQUAL)
      )
    )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) jjtn000.init(method);   
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void MultiAngleExpression(EMethod method)                                                       :
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode;
}
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    PlusLikeExpression(method)
    (
      (
        < DoubleAngleOpen >
        PlusLikeExpression(EMethod.DOUBLE_ANGLE_OPEN)
      )
    |
      (
        < DoubleAngleClose > 
        PlusLikeExpression(EMethod.DOUBLE_ANGLE_CLOSE)
      )
    |
      (
        < TripleAngleOpen > 
        PlusLikeExpression(EMethod.TRIPLE_ANGLE_OPEN)
      )
    |
      (
        < TripleAngleClose > 
        PlusLikeExpression(EMethod.TRIPLE_ANGLE_CLOSE)
      )
    )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) jjtn000.init(method);   
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void PlusLikeExpression(EMethod method)                                                       :
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode;
}
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    StarLikeExpression(method)
    (
      (
        < Plus >
        StarLikeExpression(EMethod.PLUS)
      )
    |
      (
        < Dash > StarLikeExpression(EMethod.DASH)
      )
    )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) jjtn000.init(method);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void StarLikeExpression(EMethod method)                                                       :
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode; 
}
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  DoubleStarExpression(method)
  (
    (
      (
        < Star >
        DoubleStarExpression(EMethod.STAR)
      )
    |
      (
        < Slash > DoubleStarExpression(EMethod.SLASH)
      )
    |
      (
        < Percent > DoubleStarExpression(EMethod.PERCENT)
      )
    )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) jjtn000.init(method);   
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void DoubleStarExpression(EMethod method)                                                       :
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTExpressionNode jjtn000 = new ASTExpressionNode(this, JJTEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode;
}
{/*@bgen(jjtree) #ExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    UnaryExpression(method) 
    [ 
    < DoubleStar >
    DoubleStarExpression(EMethod.DOUBLE_STAR) 
    ]
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) jjtn000.init(method);   
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void UnaryExpression(EMethod method)                                           :
{/*@bgen(jjtree) #UnaryExpressionNode( unaryMethod != null) */
  ASTUnaryExpressionNode jjtn000 = new ASTUnaryExpressionNode(this, JJTUNARYEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  EMethod unaryMethod = null;
}
{/*@bgen(jjtree) #UnaryExpressionNode( unaryMethod != null) */
  try {
/*@egen*/
  (
    (
      < DoublePlus >
      UnaryExpression(method)
      {
        unaryMethod = EMethod.DOUBLE_PLUS_PREFIX;
      }
    )
  |
    (
      < DoubleDash > UnaryExpression(method)
      {
        unaryMethod = EMethod.DOUBLE_DASH_PREFIX;
      }
    )
  |
    (
      < Plus > UnaryExpression(method)
      {
        unaryMethod = EMethod.PLUS_UNARY;
      }
    )
  |
    (
      < Dash > UnaryExpression(method)
      {
        unaryMethod = EMethod.DASH_UNARY;
      }
    )
  |
    (
      < Tilde > UnaryExpression(method)
      {
        unaryMethod = EMethod.TILDE;
      }
    )
  |
    (
      < Exclamation > UnaryExpression(method)
      {
        unaryMethod = EMethod.EXCLAMATION;
      }
    )
  | 
    PostUnaryExpression(method)
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  unaryMethod != null);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (unaryMethod != null) {
      
      jjtn000.init(method, unaryMethod);
    }
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  unaryMethod != null);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void PostUnaryExpression(EMethod method)                                               :
{/*@bgen(jjtree) #PostUnaryExpressionNode( unaryMethod != null) */
  ASTPostUnaryExpressionNode jjtn000 = new ASTPostUnaryExpressionNode(this, JJTPOSTUNARYEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  EMethod unaryMethod = null; 
}
{/*@bgen(jjtree) #PostUnaryExpressionNode( unaryMethod != null) */
  try {
/*@egen*/
  (
     PropertyExpression(method)
    [
      < DoublePlus > {  unaryMethod = EMethod.DOUBLE_PLUS_SUFFIX; }
    | 
      < DoubleDash > {  unaryMethod = EMethod.DOUBLE_DASH_SUFFIX; }
    ]
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  unaryMethod != null);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (unaryMethod != null) { 
      
      jjtn000.init(method, unaryMethod);
    }
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  unaryMethod != null);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void PropertyExpression(EMethod method)                                                               :
{/*@bgen(jjtree) #PropertyExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTPropertyExpressionNode jjtn000 = new ASTPropertyExpressionNode(this, JJTPROPERTYEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode = true;
}
{/*@bgen(jjtree) #PropertyExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    FunctionTypeUnaryExpression(method)
    (
      < Dot >
      DotProperty(EMethod.DOT)
    | < BracketOpen > Expression(EMethod.BRACKET) < BracketClose >
    | < ParenOpen > FunctionArgumentList(EMethod.PARENTHESIS) < ParenClose >
    )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) {
      
      jjtn000.init(method);
    }
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void DotProperty(EMethod method)                  :
{/*@bgen(jjtree) DotPropertyNode */
  ASTDotPropertyNode jjtn000 = new ASTDotPropertyNode(this, JJTDOTPROPERTYNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) DotPropertyNode */
  try {
/*@egen*/
  (
    [
      < AngleOpen > VariableType(null)
      (
        < Comma > VariableType(null)
      )*
      < AngleClose >
    ]
  )
  t = < Identifier >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, t.getNonnullImage());
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void IdentifierName(EMethod method)                     :
{/*@bgen(jjtree) IdentifierNameNode */
  ASTIdentifierNameNode jjtn000 = new ASTIdentifierNameNode(this, JJTIDENTIFIERNAMENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
  
}
{/*@bgen(jjtree) IdentifierNameNode */
  try {
/*@egen*/
  (
    t = < Identifier >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, t.getNonnullImage());   
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void FunctionArgumentList(EMethod method)            :
{/*@bgen(jjtree) ArrayNode */
  ASTArrayNode jjtn000 = new ASTArrayNode(this, JJTARRAYNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  
}
{/*@bgen(jjtree) ArrayNode */
  try {
/*@egen*/
  (
    [ Expression(null) ]
    (
      < Comma > Expression(null)
    )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void FunctionTypeUnaryExpression(EMethod method)                                                                  :
{/*@bgen(jjtree) #ParenthesisExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  ASTParenthesisExpressionNode jjtn000 = new ASTParenthesisExpressionNode(this, JJTPARENTHESISEXPRESSIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean createNode = false;
}
  // An opening parenthesis ( can be the start of a parenthesized
  // expression or the start of a lambda.
  //
  // The worst case scenario is 3 identical tokens. Thus we need
  // a lookahead of at least 4.
  //
  //   (foo) =>
  //
  // (foo) is a valid expression, only the arrow tells us it must be a lambda
{/*@bgen(jjtree) #ParenthesisExpressionNode( createNode = jjtree . nodeArity ( ) != 1) */
  try {
/*@egen*/
  (
    (
      VariableWithOptionalScope(method)
    |
      LiteralWithoutFunction(method)
    |
      LOOKAHEAD(4)
      Function(method)
    |
      (
        < ParenOpen > Expression(method) < ParenClose >
      )
    )
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (createNode) {
      jjtn000.init(method);
    }
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  createNode = jjtree . nodeArity ( ) != 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Variable(EMethod method)               :
{/*@bgen(jjtree) VariableNode */
  ASTVariableNode jjtn000 = new ASTVariableNode(this, JJTVARIABLENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) VariableNode */
  try {
/*@egen*/
  (
    t = < Identifier >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, null, t.getNonnullImage());
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void VariableWithOptionalScope(EMethod method)               :
{/*@bgen(jjtree) VariableNode */
  ASTVariableNode jjtn000 = new ASTVariableNode(this, JJTVARIABLENODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token part1;
  Token part2 = null;
}
{/*@bgen(jjtree) VariableNode */
  try {
/*@egen*/
  (
  part1 = < Identifier > [ < ScopeSeparator > part2 = < Identifier > ]
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    if (part2 == null) 
      jjtn000.init(method, null, part1.getNonnullImage());
    else 
      jjtn000.init(method, part1.image, part2.getNonnullImage());
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Number(EMethod method)             :
{/*@bgen(jjtree) NumberNode */
  ASTNumberNode jjtn000 = new ASTNumberNode(this, JJTNUMBERNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
  boolean isInt;
}
{/*@bgen(jjtree) NumberNode */
  try {
/*@egen*/
  (
    t = < Integer >
    {
      isInt = true;
    }
  | 
    t = < Float >
    {
      isInt = false;
    }
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, t.getNonnullImage(), isInt);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void String(EMethod method)             :
{/*@bgen(jjtree) StringNode */
  ASTStringNode jjtn000 = new ASTStringNode(this, JJTSTRINGNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  char delimiter;
}
{/*@bgen(jjtree) StringNode */
  try {
/*@egen*/
  (
    (
      delimiter = StringLiteral(null)
    )
  |
    (
      < TemplateLiteralOpen >
      (
        TemplateLiteralCharacters(null)
      |
        (
          < TemplateLiteralInlineOpen > [ Expression(null) ] < BracesClose >
        )
      )*
      < TemplateLiteralClose >
      {
        delimiter = '`';
      }
    )
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, delimiter);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

char StringLiteral(EMethod method)                       :
{/*@bgen(jjtree) StringCharactersNode */
  ASTStringCharactersNode jjtn000 = new ASTStringCharactersNode(this, JJTSTRINGCHARACTERSNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
  char delimiter;
}
{/*@bgen(jjtree) StringCharactersNode */
  try {
/*@egen*/
  (
    t = < DoubleQuotedString > { delimiter = '"'; }
  | t = < SingleQuotedString > { delimiter = '\''; }  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    String image = t.getNonnullImage();
    jjtn000.init(method, image.substring(1, image.length()-1), delimiter);
    return delimiter;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void TemplateLiteralCharacters(EMethod method)                       :
{/*@bgen(jjtree) StringCharactersNode */
  ASTStringCharactersNode jjtn000 = new ASTStringCharactersNode(this, JJTSTRINGCHARACTERSNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) StringCharactersNode */
  try {
/*@egen*/
  (
    t = < TemplateLiteralChars >  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, t.getNonnullImage(), '`');
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Array(EMethod method)            :
{/*@bgen(jjtree) ArrayNode */
  ASTArrayNode jjtn000 = new ASTArrayNode(this, JJTARRAYNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) ArrayNode */
  try {
/*@egen*/
  (
    < BracketOpen >
    (
      < BracketClose >
    |
      (
        Expression(null)
        (
          < Comma > Expression(null)
        )*
        < BracketClose >
      )
    )
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
    
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Hash(EMethod method)           :
{/*@bgen(jjtree) HashNode */
  ASTHashNode jjtn000 = new ASTHashNode(this, JJTHASHNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  
}
{/*@bgen(jjtree) HashNode */
  try {
/*@egen*/
  (
    < BracesOpen >
    (
      < BracesClose >
    |
      (
        HashEntry(null)
        (
          < Comma > HashEntry(null)
        )*
        < BracesClose >
      )
    )
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void HashEntry(EMethod method)       :
{
}
{
  (
      Literal(null)
    |
      IdentifierName(null)
  )
  < Colon > Expression(null)
}

void Null(EMethod method)           :
{/*@bgen(jjtree) NullNode */
  ASTNullNode jjtn000 = new ASTNullNode(this, JJTNULLNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) NullNode */
  try {
/*@egen*/
  < Null >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    {
      jjtn000.init(method);
    }
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Boolean(EMethod method)              :
{/*@bgen(jjtree) BooleanNode */
  ASTBooleanNode jjtn000 = new ASTBooleanNode(this, JJTBOOLEANNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean b; 
}
{/*@bgen(jjtree) BooleanNode */
  try {
/*@egen*/
  (
    < True >
    {
      b = true;
    }
  | 
    < False >
    {
      b = false;
    }
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, b);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Log(EMethod method)          :
{/*@bgen(jjtree) LogNode */
  ASTLogNode jjtn000 = new ASTLogNode(this, JJTLOGNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  ELogLevel logLevel;
}
{/*@bgen(jjtree) LogNode */
  try {
/*@egen*/
  (
    (
      < LogInfo >
      {
        logLevel = ELogLevel.INFO;
      }
    | < LogError >
      {
        logLevel = ELogLevel.ERROR;
      }
    | < LogDebug >
      {
        logLevel = ELogLevel.DEBUG;
      }
    | < LogWarn >
      {
        logLevel = ELogLevel.WARN;
      }
    )
    < ParenOpen > Expression(null) < ParenClose >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, logLevel);   
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Exception(EMethod method)                :
{/*@bgen(jjtree) ExceptionNode */
  ASTExceptionNode jjtn000 = new ASTExceptionNode(this, JJTEXCEPTIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) ExceptionNode */
  try {
/*@egen*/
  (
    < __Exception > < ParenOpen > [ Expression(null) ] < ParenClose >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method);
    
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

// function foo(x, ...bar)
// function foo(x, number... bar)

void Function(EMethod method)               :
{/*@bgen(jjtree) FunctionNode */
  ASTFunctionNode jjtn000 = new ASTFunctionNode(this, JJTFUNCTIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  boolean hasVarArg = false;
  boolean hasType = false;
}
{/*@bgen(jjtree) FunctionNode */
  try {
/*@egen*/
  (
    < ParenOpen >
    (
      [
        hasVarArg = FunctionArgument(null)
        (
          {
            if (hasVarArg)
              throw new ParseException(CmnCnst.Error.VAR_ARG_IN_NON_FINAL_PLACE, token);
          }
          (
            < Comma > hasVarArg = FunctionArgument(null)
          )
        )*
      ]
    )
    < ParenClose >
    < LambdaArrow >
    [ GenericsFunction(null) { hasType = true; } ]
    Block(null)
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {
    jjtn000.init(method, hasVarArg, hasType);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

// i Pattern.CASE_INSENSITIVE
// m Pattern.MULTILINE
// s Pattern.DOTALL
void Regex(EMethod method)            :
{/*@bgen(jjtree) RegexNode */
  ASTRegexNode jjtn000 = new ASTRegexNode(this, JJTREGEXNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) RegexNode */
  try {
/*@egen*/
  (
    t = < BackslashQuotedRegex >  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  {    
    jjtn000.init(method, t.getNonnullImage());
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Literal(EMethod method)       :
{
}
{
  LiteralWithoutFunction(method)
| Function(method)
}

void LiteralWithoutFunction(EMethod method)       :
{
}
{
  String(method)
| Number(method)
| Boolean(method)
| Array(method)
| Hash(method)
| Regex(method)
| Null(method)
| Log(method)
| Exception(method)
}