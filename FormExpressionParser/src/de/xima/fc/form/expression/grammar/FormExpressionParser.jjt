PARSER_BEGIN(FormExpressionParser)
package de.xima.fc.form.expression.grammar;
import java.lang.StringBuilder;
import java.util.ArrayList;
import java.util.List;
import de.xima.fc.form.expression.enums.EMethod;
import de.xima.fc.form.expression.enums.ELogLevel;
import org.apache.commons.lang3.StringUtils;
import de.xima.fc.form.expression.node.*;

public class FormExpressionParser
{
  private boolean _customLosAllowed = false;
  public void setLosAllowed(boolean losAllowed) {
    this._customLosAllowed = losAllowed;
  }    
}
PARSER_END(FormExpressionParser)

TOKEN_MGR_DECLS :
{
  private String currentEmbedmentContext;
  void CommonTokenAction(final Token token) {
    token.setEmbedmentContext(currentEmbedmentContext);
  }
}

< LOS >
TOKEN :
{
  < LosOpen : "[%" ([ "%", "$", "@", "=" ])* >
  {
    currentEmbedmentContext = matchedToken.image;
  }
  : CODE
| 
  < LosChar : ~[ ] >
}

< MULTI_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < MultiLineCommentClose: "*/" > : CODE
}

< MULTI_LINE_COMMENT >
MORE :
{
  < MultiLineCommentChar : ~[ ] >
}

< SINGLE_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < SingleLineCommentClose: "\n" > : CODE
}

< SINGLE_LINE_COMMENT >
MORE :
{
  < SingleLineCommentChar : ~["\n"] >
}

< CODE >
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

< AFTER_DOT >
TOKEN:
{
  < IdentifierAfterDot : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "_", "0"-"9" ])* > : CODE
}

< CODE >
MORE:
{ 
  < MultiLineCommentOpen: "/*" > : MULTI_LINE_COMMENT
| 
  < SingleLineCommentOpen: "//" > : SINGLE_LINE_COMMENT
}

< CODE >
TOKEN :
{
  < AngleOpen : "<" >
|
  < AngleClose : ">" >
|
  < Ampersand : "&" >
|
  < QuestionMark : "?" >
|
  < Plus : "+" >
|
  < Dash : "-" >
|
  < Star : "*" >
|
  < Slash : "/" >
|
  < Circumflex : "^" >
|
  < Bar : "|" >
| 
  < Equal : "=" >
| 
  < ParenOpen : "(" >
| 
  < ParenClose : ")" >
|
  < BracesOpen : "{" >
|
  < BracesClose : "}" >
|
  < BracketOpen : "[" >
|
  < BracketClose : "]" >
|
  < Comma : "," >
|
  < Colon : ":" >
|
  < Dot : "." > : AFTER_DOT
|
  < SemiColon : ";" >
|
  < Exclamation : "!" >
|
  < Percent : "%" >
|
  < LosBodyClose : "%]" > : LOS
|
  < ScopeSeparator : "::" >
|
  < LambdaArrow : "->" >
|
  < DoublePlus : "++" >
|
  < DoubleDash : "--" >
|
  < PlusEqual : "+=" >
|
  < DashEqual : "-=" >
|
  < StarEqual : "*=" >
|
  < SlashEqual : "/=" >
|
  < PercentEqual : "%=" >
|
  < DoubleAmpersand : "&&" >
|
  < DoubleBar : "||" >
|
  < AmpersandEqual : "&=" >
|
  < AngleOpenEqual : "<=" >
|
  < AngleCloseEqual : ">=" >
|
  < BarEqual : "|=" >
|
  < CircumflexEqual : "^=" >
|
  < DoubleStar : "**" >
| 
  < DoubleEqual : "==" >
| 
  < If : "if" >
| 
  < Do : "do" >
| 
  < ExclamationEqual : "!=" >
| 
  < EqualTilde : "=~" >
|
  < ExclamationTilde : "!~" >
|
  < DoubleAngleOpen : "<<" > 
|
  < DoubleAngleClose : ">>" > 
| 
  < DoubleStarEqual : "**=" >
| 
  < DoubleAmpersandEqual : "&&=" >
| 
  < DoubleBarEqual : "||=" >
| 
  < DoubleAngleOpenEqual : "<<=" >
| 
  < DoubleAngleCloseEqual : ">>=" >
| 
  < TripleAngleOpenEqual : "<<<=" >
| 
  < TripleAngleCloseEqual : ">>>=" >
|
  < TripleAngleOpen : ">>>" >
|
  < TripleAngleClose : "<<<" >
| 
  < TripleEqual : "===" >
| 
  < ExclamationDoubleEqual : "!==" >
| 
  < For : "for" >
| 
  < Try : "try" >
| 
  < With : "with" >
| 
  < Else : "else" >
| 
  < Case : "case" >
| 
  < True : "true" >
| 
  < Null : "null" >
| 
  < Break : "break" >
| 
  < While : "while" >
| 
  < Catch : "catch" >
| 
  < Throw : "throw" >
| 
  < False : "false" >
| 
  < Return : "return" >
| 
  < Switch : "switch" >
| 
  < LogInfo : "loginfo" >
| 
  < LogWarn : "logwarn" >
| 
  < Default : "default" >
| 
  < Continue : "continue" >
| 
  < Function : "function" >
| 
  < LogError : "logerror" >
| 
  < LogDebug : "logdebug" >
| 
  < Exception : "exception" >
| 
  < Identifier : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "_", "0"-"9" ])* >
| 
  < Integer : ([ "0"-"9" ])+ >
| 
  < Float :
    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< EXPONENT >)?
  | "." ([ "0"-"9" ])+ (< EXPONENT >)?
  | ([ "0"-"9" ])+ < EXPONENT > 
  >
| 
  < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >
| 
  < DoubleQuotedString :
    "\""
    (
      ("\\" ~[ ])
    | ~[ "\\", "\"" ]
    )*
    "\"" >
| 
  < SingleQuotedString :
    "'"
    (
      ("\\" ~[ ])
    | ~[ "\\", "'" ]
    )*
    "'" >
|
  < Regex :
    "#"
    (
      ("\\" ~[ ])
    | ~[ "\\", "#" ]
    )*
    "#"
    ([ "i", "m", "s" ])* >
}

Node Template(EMethod method) #StatementListNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
    (
      (
        LosChars(null)
        [
          LosOpen(null) TemplateProgram(null)
        ]
      )
    | 
      (        LosOpen(null) TemplateProgram(null)
      )
    )
    < EOF >
  )
  {
    if (token_source.curLexState == FormExpressionParserConstants.CODE)
      throw new ParseException("Final code block in templates must be closed.");
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
    return jjtThis;
  }
}

/* Los = Literal Output Statement */
void LosChars(EMethod method) #LosNode :
{
  Token t;
  final StringBuilder sb = new StringBuilder();
  jjtThis.openNodeScope(token);
}
{
  (
    (
      t = < LosChar >
      {
        sb.append(t.image.charAt(0));
      }
    )+
  )
  {
    jjtThis.init(method, sb.toString(), null, false);
    jjtThis.closeNodeScope(token);
  }
}

void LosOpen(EMethod method) #LosNode :
{
  Token t;
  jjtThis.openNodeScope(token);
}
{
  (
    t = < LosOpen >
  )
  {
    if (!_customLosAllowed) throw new ParseException(
      String.format("Embedded blocks are not allowed. (line %s, column %s)", token.beginLine, token.beginColumn));
    jjtThis.init(method, StringUtils.EMPTY, t.image, false);
    jjtThis.closeNodeScope(token);
  }
}


void LosBody(EMethod method) #LosNode :
{
  Token t = null;
  Token p = null;
  final StringBuilder sb = new StringBuilder();
  jjtThis.openNodeScope(token);
}
{
  (
    < LosBodyClose >
    (
      t = < LosChar >
      {
        sb.append(t.image.charAt(0));
      }
    )*
    [ p = < LosOpen > ]
  )
  {
    if (!_customLosAllowed) throw new ParseException(
      String.format("Embedded blocks are not allowed. (line %s, column %s)", token.beginLine, token.beginColumn));
    jjtThis.init(method, sb.toString(), p != null ? p.image : null, true);
    jjtThis.closeNodeScope(token);
  }
}

Node CompleteProgram(EMethod method) #StatementListNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
    (
      (
        ClauseOrStatement(null)
      )+
      < EOF >
    )
  | < EOF >
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
    return jjtThis;
  }
}

void TemplateProgram(EMethod method) #StatementListNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
    (
      ClauseOrStatement(null)
    | LosBody(null)
    )+
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void ClauseOrStatement(EMethod method) #void :
{
}
{
  (
    ForLoop(method)
  | IfClause(method)
  | FunctionClause(method)
  | WhileLoop(method)
  | DoWhileLoop(method)
  | SwitchClause(method)
  | TryClause(method)
  | WithClause(method)
  | ThrowClause(method)
  | BreakClause(method)
  | ContinueClause(method)
  | ReturnClause(method)
  | Statement(method)
  )
}

void FunctionClause(EMethod method) #FunctionClauseNode :
{
  Token t;
  jjtThis.openNodeScope(token);
}
{
  (
    < Function > VariableWithOptionalScope(null) < ParenOpen >
    (
      [ IdentifierName(null) ]
      (
        < Comma > IdentifierName(null)
      )*
    )
    < ParenClose >
    (
      Block(null)
    )
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void WithClause(EMethod method) #WithClauseNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
    < With > < ParenOpen > IdentifierName(null)
    (
      < Comma > IdentifierName(null)
    )*
    < ParenClose > BlockOrClause(null)
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void ContinueClause(EMethod method) #ContinueClauseNode :
{
  Token t = null;
}
{
  (
  < Continue > [ t = < Identifier > ] < SemiColon >
  )
  {
    jjtThis.init(method, t == null ? null : t.image);
    jjtThis.closeNodeScope(token);
  }
}

void BreakClause(EMethod method) #BreakClauseNode :
{
  Token t = null;
  jjtThis.openNodeScope(token);
}
{
  (
  < Break > [ t = < Identifier > ] < SemiColon >
  )
  {
    jjtThis.init(method, t == null ? null : t.image);
    jjtThis.closeNodeScope(token);
  }
}

void ReturnClause(EMethod method) #ReturnClauseNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
    < Return > [ Expression(null) ] < SemiColon >
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void ThrowClause(EMethod method) #ThrowClauseNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
    < Throw > Expression(null) < SemiColon >
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void SwitchClause(EMethod method) #SwitchClauseNode :
{
  Token label = null;
  jjtThis.openNodeScope(token);
}
{
  (
    < Switch > [< AngleOpen > label = < Identifier > < AngleClose >] < ParenOpen > Expression(null) < ParenClose > < BracesOpen >
    (
      SwitchCase()
    )*
    [ 
    SwitchDefault() 
    ] 
    < BracesClose >
  )
  {
    jjtThis.init(method, label != null ? label.image : null);
    jjtThis.closeNodeScope(token);
  }
}

void SwitchCase() #void :
{
}
{
  (
    (
      < Case > Expression(EMethod.SWITCHCASE) < Colon >
    )+
    (
      ClauseOrStatement(EMethod.SWITCHCLAUSE)
    )+
  )
}

void SwitchDefault() #void :
{
}
{
  (
    < Default > < Colon >
    (
      ClauseOrStatement(EMethod.SWITCHDEFAULT)
    )+
  )
}

void TryClause(EMethod method) #TryClauseNode :
{
  Token t;
  jjtThis.openNodeScope(token);
}
{
  (
    < Try >
    (
      Block(null)
    )
    < Catch > < ParenOpen > t = < Identifier > < ParenClose >
    (
      Block(null)
    )
  )
  {
    jjtThis.init(method, t == null ? null : t.image);
    jjtThis.closeNodeScope(token);
  }
}

void DoWhileLoop(EMethod method) #DoWhileLoopNode :
{
  Token label = null;
  jjtThis.openNodeScope(token);
}
{
  (
    < Do > [< AngleOpen > label = < Identifier > < AngleClose >]
    BlockOrClause(null) 
    < While > < ParenOpen > Expression(null) < ParenClose > < SemiColon >
  )
  {
    jjtThis.init(method, label != null ? label.image : null);
  }
}

void WhileLoop(EMethod method) #WhileLoopNode :
{
  Token label = null;
  jjtThis.openNodeScope(token);
}
{
  (
    < While > [< AngleOpen > label = < Identifier > < AngleClose >] < ParenOpen > Expression(null) < ParenClose > 
    BlockOrClause(null)
  )
  {
    jjtThis.init(method, label != null ? label.image : null);
    jjtThis.closeNodeScope(token);
  }
}

void ForLoop(EMethod method) #ForLoopNode :
{
  Token label = null;
  Token iteratingLoopVariable = null;
  jjtThis.openNodeScope(token);
}
{
  (
    < For > [< AngleOpen > label = < Identifier > < AngleClose >] < ParenOpen >
    (
      LOOKAHEAD(< Identifier > < Colon >)
      (
        iteratingLoopVariable = < Identifier > < Colon > Expression(null)
      )
    |
      (
        ExpressionListCommaSeparated(null) < SemiColon > ExpressionListCommaSeparated(null) < SemiColon > ExpressionListCommaSeparated(null)
      )
    )
    < ParenClose > 
    BlockOrClause(null)
  )
  {
    jjtThis.init(method, iteratingLoopVariable != null ? iteratingLoopVariable.image : null, label != null ? label.image : null);
    jjtThis.closeNodeScope(token);
  }
}

void IfClause(EMethod method) #IfClauseNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
    < If > 
    < ParenOpen > Expression(null) < ParenClose > 
    BlockOrClause(null)
    [
      LOOKAHEAD(1)
      < Else > 
      BlockOrClause(null)
    ]
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void BlockOrClause(EMethod method) #void :
{
}
{
  LOOKAHEAD(< BracesOpen >)
  Block(method)
| ClauseOrStatement(method)
}

void Block(EMethod method) #StatementListNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    < BracesOpen >
    (
      (
        ClauseOrStatement(null)
      | LosBody(null)
      )*
    )
    < BracesClose >
  )
  {
    if (createNode) {
      jjtThis.init(method);
      jjtThis.closeNodeScope(token);
    }
  }
}

void ExpressionListCommaSeparated(EMethod method) #StatementListNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
    (
      Expression(null)
    )?
    (
      < Comma > Expression(null)
    )*
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void Statement(EMethod method) #StatementListNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    (
      (Expression(method) (< SemiColon > | LosBody(null)))
    )
  | EmptyStatement(method)
  )
  {
    if (createNode) { 
      jjtThis.init(method);
      jjtThis.closeNodeScope(token);
    }
  }
}

Node EmptyStatement(EMethod method) #EmptyNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
  < SemiColon >
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
    return jjtThis;
  }
}

void Expression(EMethod method) #void :
{
}
{
  EqualTypeExpression(method)
}

void EqualTypeExpression(EMethod method) #AssignmentExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    TernaryExpression(method)
    (
      (
        < Equal >
        TernaryExpression(EMethod.EQUAL)
      )
    |
      (
        < PlusEqual > TernaryExpression(EMethod.PLUS_EQUAL)
      )
    |
      (
        < DashEqual > TernaryExpression(EMethod.DASH_EQUAL)
      )
    |
      (
        < DoubleStarEqual > TernaryExpression(EMethod.DOUBLE_STAR_EQUAL)
      )
    |
      (
        < StarEqual > TernaryExpression(EMethod.STAR_EQUAL)
      )
    |
      (
        < SlashEqual > TernaryExpression(EMethod.SLASH_EQUAL)
      )
    |
      (
        < PercentEqual > TernaryExpression(EMethod.PERCENT_EQUAL)
      )
    |
      (
        < DoubleAngleOpenEqual > TernaryExpression(EMethod.DOUBLE_ANGLE_OPEN_EQUAL)
      )
    |
      (
        < DoubleAngleCloseEqual > TernaryExpression(EMethod.DOUBLE_ANGLE_CLOSE_EQUAL)
      )
    |
      (
        < TripleAngleOpenEqual > TernaryExpression(EMethod.TRIPLE_ANGLE_OPEN_EQUAL)
      )
    |
      (
        < TripleAngleCloseEqual > TernaryExpression(EMethod.TRIPLE_ANGLE_CLOSE_EQUAL)
      )
    |
      (
        < DoubleAmpersandEqual > TernaryExpression(EMethod.DOUBLE_AMPERSAND_EQUAL)
      )
    |
      (
        < DoubleBarEqual > TernaryExpression(EMethod.DOUBLE_BAR_EQUAL)
      )
    |
      (
        < AmpersandEqual > TernaryExpression(EMethod.AMPERSAND_EQUAL)
      )
    |
      (
        < CircumflexEqual > TernaryExpression(EMethod.CIRCUMFLEX_EQUAL)
      )
    |
      (
        < BarEqual > TernaryExpression(EMethod.BAR_EQUAL)
      )
    )*
  )
  {
    jjtThis.closeNodeScope(token);
    if (createNode) jjtThis.init(method);
  }
}

void TernaryExpression(EMethod method) #TernaryExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    DoubleBarExpression(method) [
      < QuestionMark > DoubleBarExpression(method) < Colon > DoubleBarExpression(method)
    ]
  )
  {
    if (createNode) jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void DoubleBarExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    DoubleAmpersandExpression(method)
    (
      < DoubleBar >
      DoubleAmpersandExpression(EMethod.DOUBLE_BAR)
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void DoubleAmpersandExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    BarExpression(method)
    (
      < DoubleAmpersand >
      BarExpression(EMethod.DOUBLE_AMPERSAND)
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void BarExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    CircumflexExpression(method)
    (
      < Bar >
      CircumflexExpression(EMethod.BAR)
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void CircumflexExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    AmpersandExpression(method)
    (
      < Circumflex >
      AmpersandExpression(EMethod.CIRCUMFLEX)
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void AmpersandExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    DoubleEqualTypeExpression(method)
    (
      < Ampersand >
      DoubleEqualTypeExpression(EMethod.AMPERSAND)
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void DoubleEqualTypeExpression(EMethod method) #ComparisonExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    AngleTypeExpression(method)
    (
      (
        < ExclamationTilde >
        AngleTypeExpression(EMethod.EXCLAMATION_TILDE)
      )
    |
      (
        < EqualTilde >
        AngleTypeExpression(EMethod.EQUAL_TILDE)
      )
    |
      (
        < TripleEqual >
        AngleTypeExpression(EMethod.TRIPLE_EQUAL)
      )
    |
      (
        < DoubleEqual >
        AngleTypeExpression(EMethod.DOUBLE_EQUAL)
      )
    |
      (
        < ExclamationDoubleEqual >
        AngleTypeExpression(EMethod.EXCLAMATION_DOUBLE_EQUAL)
      )
    |
      (
        < ExclamationEqual >
        AngleTypeExpression(EMethod.EXCLAMATION_EQUAL)
      )
    )*
  )
  {
    if (createNode) {
      jjtThis.closeNodeScope(token);
      jjtThis.init(method);
    }
  }
}

void AngleTypeExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    MultiAngleExpression(method)
    (
      (
        < AngleOpen > MultiAngleExpression(EMethod.ANGLE_OPEN)
      )
    |
      (
        < AngleClose > MultiAngleExpression(EMethod.ANGLE_CLOSE)
      )
    |
      (
        < AngleOpenEqual > MultiAngleExpression(EMethod.ANGLE_OPEN_EQUAL)
      )
    |
      (
        < AngleCloseEqual > MultiAngleExpression(EMethod.ANGLE_CLOSE_EQUAL)
      )
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void MultiAngleExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    PlusLikeExpression(method)
    (
      (
        < DoubleAngleOpen >
        PlusLikeExpression(EMethod.DOUBLE_ANGLE_OPEN)
      )
    |
      (
        < DoubleAngleClose > 
        PlusLikeExpression(EMethod.DOUBLE_ANGLE_CLOSE)
      )
    |
      (
        < TripleAngleOpen > 
        PlusLikeExpression(EMethod.TRIPLE_ANGLE_OPEN)
      )
    |
      (
        < TripleAngleClose > 
        PlusLikeExpression(EMethod.TRIPLE_ANGLE_CLOSE)
      )
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void PlusLikeExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    StarLikeExpression(method)
    (
      (
        < Plus >
        StarLikeExpression(EMethod.PLUS)
      )
    |
      (
        < Dash > StarLikeExpression(EMethod.DASH)
      )
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void StarLikeExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  DoubleStarExpression(method)
  (
    (
      (
        < Star >
        DoubleStarExpression(EMethod.STAR)
      )
    |
      (
        < Slash > DoubleStarExpression(EMethod.SLASH)
      )
    |
      (
        < Percent > DoubleStarExpression(EMethod.PERCENT)
      )
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void DoubleStarExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  jjtThis.openNodeScope(token);
}
{
  (
    UnaryExpression(method) 
    [ 
    < DoubleStar >
    DoubleStarExpression(EMethod.DOUBLE_STAR) 
    ]
  )
  {
    if (createNode) jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void UnaryExpression(EMethod method) #UnaryExpressionNode(unaryMethod != null) :
{
  EMethod unaryMethod = null;
  jjtThis.openNodeScope(token);
}
{
  (
    (
      < DoublePlus >
      UnaryExpression(method)
      {
        unaryMethod = EMethod.DOUBLE_PLUS_PREFIX;
      }
    )
  |
    (
      < DoubleDash > UnaryExpression(method)
      {
        unaryMethod = EMethod.DOUBLE_DASH_PREFIX;
      }
    )
  |
    (
      < Plus > UnaryExpression(method)
      {
        unaryMethod = EMethod.PLUS_UNARY;
      }
    )
  |
    (
      < Dash > UnaryExpression(method)
      {
        unaryMethod = EMethod.DASH_UNARY;
      }
    )
  |
    (
      < Exclamation > UnaryExpression(method)
      {
        unaryMethod = EMethod.EXCLAMATION;
      }
    )
  | 
    PropertyExpression(method)
  )
  {
    if (unaryMethod != null) jjtThis.init(method, unaryMethod);
    jjtThis.closeNodeScope(token);
  }
}

void PropertyExpression(EMethod method) #PropertyExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode = true;
  jjtThis.openNodeScope(token);
}
{
  (
    FunctionTypeUnaryExpression(method)
    (
      < Dot >
      IdentifierNameAfterDot(EMethod.DOT)
    | < BracketOpen > Expression(EMethod.BRACKET) < BracketClose >
    | < ParenOpen > FunctionArgumentList(EMethod.PARENTHESIS) < ParenClose >
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void IdentifierNameAfterDot(EMethod method) #IdentifierNameNode :
{
  Token t;
  jjtThis.openNodeScope(token);
}
{
  (
    t = < IdentifierAfterDot >
  )
  {
    jjtThis.init(method, t.image);
    jjtThis.closeNodeScope(token);
  }
}


void IdentifierName(EMethod method) #IdentifierNameNode :
{
  Token t;
  jjtThis.openNodeScope(token);
}
{
  (
    t = < Identifier >
  )
  {
    jjtThis.init(method, t.image);
    jjtThis.closeNodeScope(token);
  }
}

void FunctionArgumentList(EMethod method) #ArrayNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
    [ Expression(null) ]
    (
      < Comma > Expression(null)
    )*
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void FunctionTypeUnaryExpression(EMethod method) #ParenthesisExpressionNode(createNode) :
{
  boolean createNode = false;
  jjtThis.openNodeScope(token);
}
{
  (
    (
      Literal(method)
    | 
      VariableWithOptionalScope(method)
    |
      (
        < ParenOpen > Expression(null) < ParenClose > { createNode = true; }
      )
    )
  )
  {
    if (createNode) { 
      jjtThis.closeNodeScope(token);
      jjtThis.init(method);
    }
  }
}

void VariableWithOptionalScope(EMethod method) #VariableNode :
{
  Token part1;
  Token part2 = null;
  jjtThis.openNodeScope(token);
}
{
  (
  part1 = < Identifier > [ < ScopeSeparator > part2 = < Identifier > ]
  )
  {
    if (part2 == null) 
    jjtThis.init(method, null, part1.image);
    else 
    jjtThis.init(method, part1.image, part2.image);
    jjtThis.closeNodeScope(token);
  }
}

void Number(EMethod method) #NumberNode :
{
  Token t;
  boolean isInt;
  jjtThis.openNodeScope(token);
}
{
  (
    t = < Integer >
    {
      isInt = true;
    }
  | 
    t = < Float >
    {
      isInt = false;
    }
  )
  {
    jjtThis.closeNodeScope(token);
    jjtThis.init(method, t.image, isInt);
  }
}

void String(EMethod method) #StringNode :
{
  Token t;
  char delimiter;
  jjtThis.openNodeScope(token);
}
{
  (
    t = < SingleQuotedString >
    {
      delimiter = '\'';
    }
  | 
    t = < DoubleQuotedString >
    {
      delimiter = '"';
    }
  )
  {
    jjtThis.closeNodeScope(token);
    jjtThis.init(method, t.image, delimiter);
  }
}

void Array(EMethod method) #ArrayNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
    < BracketOpen >
    (
      < BracketClose >
    |
      (
        Expression(null)
        (
          < Comma > Expression(null)
        )*
        < BracketClose >
      )
    )
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void Hash(EMethod method) #HashNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
    < BracesOpen >
    (
      < BracesClose >
    |
      (
        HashEntry(null)
        (
          < Comma > HashEntry(null)
        )*
        < BracesClose >
      )
    )
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void HashEntry(EMethod method) #void :
{
}
{
  (
      Literal(null)
    |
      IdentifierName(null)
  )
  < Colon > Expression(null)
}

void Null(EMethod method) #NullNode :
{
  jjtThis.openNodeScope(token);
}
{
  < Null >
  {
    {
      jjtThis.init(method);
      jjtThis.closeNodeScope(token);
    }
  }
}

void Boolean(EMethod method) #BooleanNode :
{
  boolean b;
  jjtThis.openNodeScope(token);
}
{
  (
    < True >
    {
      b = true;
    }
  | 
    < False >
    {
      b = false;
    }
  )
  {
    jjtThis.init(method, b);
    jjtThis.closeNodeScope(token);
  }
}

void Log(EMethod method) #LogNode :
{
  ELogLevel logLevel;
  jjtThis.openNodeScope(token);
}
{
  (
    (
      < LogInfo >
      {
        logLevel = ELogLevel.INFO;
      }
    | < LogError >
      {
        logLevel = ELogLevel.ERROR;
      }
    | < LogDebug >
      {
        logLevel = ELogLevel.DEBUG;
      }
    | < LogWarn >
      {
        logLevel = ELogLevel.WARN;
      }
    )
    < ParenOpen > Expression(null) < ParenClose >
  )
  {
    jjtThis.init(method, logLevel);
    jjtThis.closeNodeScope(token);
  }
}

void Exception(EMethod method) #ExceptionNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
    < Exception > < ParenOpen > Expression(null) < ParenClose >
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

void Function(EMethod method) #FunctionNode :
{
  jjtThis.openNodeScope(token);
}
{
  (
    < LambdaArrow > < ParenOpen >
    (
      [ IdentifierName(null) ]
      (
        < Comma > IdentifierName(null)
      )*
    )
    < ParenClose >
    (
      Block(null)
    )
  )
  {
    jjtThis.init(method);
    jjtThis.closeNodeScope(token);
  }
}

// i Pattern.CASE_INSENSITIVE
// m Pattern.MULTILINE
// s Pattern.DOTALL
void Regex(EMethod method) #RegexNode :
{
  Token t;
  jjtThis.openNodeScope(token);
}
{
  (
    t = < Regex >  )
  {
    jjtThis.closeNodeScope(token);
    jjtThis.init(method, t.image);
  }
}

void Literal(EMethod method) #void :
{
}
{
  Array(method)
| Hash(method)
| String(method)
| Regex(method)
| Number(method)
| Boolean(method)
| Null(method)
| Log(method)
| Function(method)
| Exception(method)
}
