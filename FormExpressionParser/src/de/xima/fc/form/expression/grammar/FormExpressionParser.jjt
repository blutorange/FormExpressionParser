options {
  BUILD_NODE_FILES = false;
  MULTI = true;
  NODE_DEFAULT_VOID = false;
  NODE_CLASS="";
  NODE_EXTENDS="";
  NODE_FACTORY="";
  NODE_PACKAGE="";
  NODE_PREFIX="AST";
  NODE_SCOPE_HOOK = false;
  NODE_USES_PARSER = true;
  TRACK_TOKENS = true;
  VISITOR = false;
  VISITOR_DATA_TYPE="Object";
  VISITOR_EXCEPTION="";
  VISITOR_RETURN_TYPE="Object";

  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER  = true;
  CACHE_TOKENS = false;
  CHOICE_AMBIGUITY_CHECK = 2;
  COMMON_TOKEN_ACTION = true;
  DEBUG_LOOKAHEAD = false;
  DEBUG_PARSER = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  FORCE_LA_CHECK = false;
  GENERATE_ANNOTATIONS = true;
  GENERATE_GENERICS = true;
  GENERATE_CHAINED_EXCEPTION = false;
  GENERATE_STRING_BUILDER = false;
  GRAMMAR_ENCODING="UTF-8";
  IGNORE_CASE  = false;
  JAVA_UNICODE_ESCAPE = false;
  JDK_VERSION="1.7";
  KEEP_LINE_COLUMN = true;
  LOOKAHEAD = 1;
  OTHER_AMBIGUITY_CHECK = 1;
  UNICODE_INPUT = true;
  USER_CHAR_STREAM = false;
  USER_TOKEN_MANAGER = false;
  SANITY_CHECK = true;
  SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
  STATIC = false;
  TOKEN_MANAGER_USES_PARSER = true;
  TOKEN_EXTENDS = "AToken";
  TOKEN_FACTORY = "";
}
PARSER_BEGIN(FormExpressionParser)
package de.xima.fc.form.expression.grammar;
import java.lang.StringBuilder;
import java.util.ArrayList;
import java.util.List;
import de.xima.fc.form.expression.enums.EMethod;
import de.xima.fc.form.expression.enums.ELogLevel;
import org.apache.commons.lang3.StringUtils;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import com.google.common.collect.ImmutableList;
import de.xima.fc.form.expression.iface.parse.IComment;
import de.xima.fc.form.expression.impl.formexpression.CommentFactory;
import de.xima.fc.form.expression.node.*;

public class FormExpressionParser
{
  private boolean _customLosAllowed = false;
  /** A list of all the comments occurring in the program. */
  @Nonnull private ImmutableList.Builder<IComment> _comments = new ImmutableList.Builder<IComment>();
  /** Current embedment context, or null when not in template mode. */
  @Nullable private String _currentEmbedmentContext;
  void setCurrentEmbedmentContext(String currentEmbedmentContext) {
    this._currentEmbedmentContext = currentEmbedmentContext;
  }
  void addComment(@Nonnull Token commentToken) {
    _comments.add(CommentFactory.fromToken(commentToken));
  }
  @Nullable public String getCurrentEmbedmentContext() {
    return _currentEmbedmentContext;
  }
  public void setLosAllowed(boolean losAllowed) {
    this._customLosAllowed = losAllowed;
  }
  @Nonnull public ImmutableList<IComment> buildComments() {
    return _comments.build();
  }
}
PARSER_END(FormExpressionParser)

TOKEN_MGR_DECLS :
{
  private int nestLevelTypeDecl = 0;
  void CommonTokenAction(final Token token) {
    // Retrieve all comments, if there are any.
    if (parser == null) return;
    Token special = token;
    if (token.specialToken != null) {
      while (special.specialToken != null) special = special.specialToken;
      while (special != null) {
        parser.addComment(special);
        special = special.next;
      }
    }
  }
}

< LOS >
TOKEN :
{
  < LosOpen : "[%" ([ "%", "$", "@", "=" ])* >
  {
    if (parser != null) parser.setCurrentEmbedmentContext(matchedToken.image);
  }
  : CODE
| 
  < LosChar : ~[ ] >
}

< MULTI_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < MultiLineComment: "*/" > : CODE
}

< MULTI_LINE_COMMENT >
MORE :
{
  < ~[ ] >
}

< AFTER_DOT >
TOKEN:
{
  < IdentifierAfterDot : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "_", "0"-"9" ])* > : CODE
}

< CODE >
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

< CODE >
MORE:
{ 
  < "/*" > : MULTI_LINE_COMMENT
}

< CODE >
SPECIAL_TOKEN:
{ 
  < SingleLineComment: "//" (~["\n"])* ("\n")?>
}

< CODE >
TOKEN :
{
  < AngleOpen : "<" >
|
  < AngleClose : ">" >
|
  < Ampersand : "&" >
|
  < QuestionMark : "?" >
|
  < Plus : "+" >
|
  < Dash : "-" >
|
  < Star : "*" >
|
  < Slash : "/" >
|
  < Circumflex : "^" >
|
  < Bar : "|" >
| 
  < Equal : "=" >
| 
  < Tilde : "~" >
| 
  < ParenOpen : "(" >
| 
  < ParenClose : ")" >
|
  < BracesOpen : "{" >
|
  < BracesClose : "}" >
|
  < BracketOpen : "[" >
|
  < BracketClose : "]" >
|
  < Comma : "," >
|
  < Colon : ":" >
|
  < Dot : "." > : AFTER_DOT
|
  < SemiColon : ";" >
|
  < Exclamation : "!" >
|
  < Percent : "%" >
|
  < LosBodyClose : "%]" > : LOS
|
  < ScopeSeparator : "::" >
|
  < LambdaArrow : "->" >
|
  < DoublePlus : "++" >
|
  < DoubleDash : "--" >
|
  < PlusEqual : "+=" >
|
  < DashEqual : "-=" >
|
  < StarEqual : "*=" >
|
  < SlashEqual : "/=" >
|
  < PercentEqual : "%=" >
|
  < DoubleAmpersand : "&&" >
|
  < DoubleBar : "||" >
|
  < AmpersandEqual : "&=" >
|
  < AngleOpenEqual : "<=" >
|
  < AngleCloseEqual : ">=" >
|
  < BarEqual : "|=" >
|
  < CircumflexEqual : "^=" >
|
  < DoubleStar : "**" >
| 
  < DoubleEqual : "==" >
| 
  < If : "if" >
| 
  < Do : "do" >
| 
  < ExclamationEqual : "!=" >
| 
  < EqualTilde : "=~" >
|
  < ExclamationTilde : "!~" >
|
  < DoubleAngleOpen : "<<" > 
|
  < DoubleAngleClose : ">>" > 
| 
  < DoubleStarEqual : "**=" >
| 
  < DoubleAmpersandEqual : "&&=" >
| 
  < DoubleBarEqual : "||=" >
| 
  < DoubleAngleOpenEqual : "<<=" >
| 
  < DoubleAngleCloseEqual : ">>=" >
| 
  < TripleAngleOpenEqual : "<<<=" >
| 
  < TripleAngleCloseEqual : ">>>=" >
|
  < TripleAngleOpen : ">>>" >
|
  < TripleAngleClose : "<<<" >
| 
  < TripleEqual : "===" >
| 
  < ExclamationDoubleEqual : "!==" >
| 
  < For : "for" >
| 
  < Try : "try" >
| 
  < Var : "var" >
| 
  < With : "with" >
| 
  < Else : "else" >
| 
  < Case : "case" >
|
  < True : "true" >
| 
  < Null : "null" >
| 
  < Break : "break" >
| 
  < While : "while" >
| 
  < Catch : "catch" >
|
  < __Error : "error" >
| 
  < Throw : "throw" >
| 
  < Scope : "scope" >
| 
  < False : "false" >
| 
  < Return : "return" >
| 
  < Switch : "switch" >
| 
  < Global : "global" >
| 
  < Require : "require" >
| 
  < LogInfo : "loginfo" >
| 
  < LogWarn : "logwarn" >
| 
  < Default : "default" >
| 
  < Continue : "continue" >
| 
  < Function : "function" >
| 
  < LogError : "logerror" >
| 
  < LogDebug : "logdebug" >
| 
  < Identifier : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "_", "0"-"9" ])* >
| 
  < Integer : ([ "0"-"9" ])+ >
| 
  < Float :
    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< EXPONENT >)?
  | "." ([ "0"-"9" ])+ (< EXPONENT >)?
  | ([ "0"-"9" ])+ < EXPONENT > 
  >
| 
  < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >
| 
  < DoubleQuotedString :
    "\""
    (
      ("\\" ~[ ])
    | ~[ "\\", "\"" ]
    )*
    "\"" >
| 
  < SingleQuotedString :
    "'"
    (
      ("\\" ~[ ])
    | ~[ "\\", "'" ]
    )*
    "'" >
|
  < BackslashQuotedRegex :
    "#"
    (
      ("\\" ~[ ])
    | ~[ "\\", "#" ]
    )*
    "#"
    ([ "i", "m", "s" ])* >
}

Node Template(EMethod method) #StatementListNode :
{
}
{
  (
    (
      (
        LosChars(null)
        [
          LosOpen(null) TemplateProgram(null)
        ]
      )
    | 
      (        LosOpen(null) TemplateProgram(null)
      )
    )
    < EOF >
  )
  {
    if (token_source.curLexState == FormExpressionParserConstants.CODE)
      throw new ParseException("Final code block in templates must be closed.");
    jjtThis.init(method);
    
    return jjtThis;
  }
}

/* Los = Literal Output Statement */
void LosChars(EMethod method) #LosNode :
{
  Token t;
  final StringBuilder sb = new StringBuilder();
  
}
{
  (
    (
      t = < LosChar >
      {
        sb.append(t.image.charAt(0));
      }
    )+
  )
  {
    jjtThis.init(method, sb.toString(), null, false);
    
  }
}

void LosOpen(EMethod method) #LosNode :
{
  Token t;
  
}
{
  (
    t = < LosOpen >
  )
  {
    if (!_customLosAllowed) throw new ParseException(
      java.lang.String.format("Embedded blocks are not allowed. (line %s, column %s)", token.beginLine, token.beginColumn));
    jjtThis.init(method, StringUtils.EMPTY, t.image, false);
    
  }
}


void LosBody(EMethod method) #LosNode :
{
  Token t = null;
  Token p = null;
  final StringBuilder sb = new StringBuilder();
  
}
{
  (
    < LosBodyClose >
    (
      t = < LosChar >
      {
        sb.append(t.image.charAt(0));
      }
    )*
    [ p = < LosOpen > ]
  )
  {
    if (!_customLosAllowed) throw new ParseException(
      java.lang.String.format("Embedded blocks are not allowed. (line %s, column %s)", token.beginLine, token.beginColumn));
    jjtThis.init(method, sb.toString(), p != null ? p.image : null, true);
    
  }
}

Node CompleteProgram(EMethod method) #StatementListNode :
{
}
{
  (
    (
      (
        ClauseOrStatement(null)
      | ScopeDefinition(null)
      )+
      < EOF >
    )
  | < EOF >
  )
  {
    jjtThis.init(method);
    
    return jjtThis;
  }
}

void TemplateProgram(EMethod method) #StatementListNode :
{
}
{
  (
    (
      ClauseOrStatement(null)
    | ScopeDefinition(null)
    | LosBody(null)
    )+
  )
  {
    jjtThis.init(method);
    
  }
}

void ScopeDefinition(EMethod method) #void :
{
}
{
  (      ScopeExternal(method)
    | ScopeGlobal(method)
    | ScopeManual(method)
  )
}

void ScopeGlobal(EMethod method) #ScopeGlobalNode :
{
}
{
  (
    < Global > < Scope > < BracesOpen >
    (
      VariableDeclarationClause(null)
    )*
    < BracesClose >
  )
  {
    jjtThis.init(method);
  }
}

void ScopeManual(EMethod method) #ScopeManualNode :
{
  Token t;
}
{
  (
    < Scope > t = < Identifier > < BracesOpen >
    (
      VariableDeclarationClause(method)
    )*
    < BracesClose >
  )
  {
    jjtThis.init(method, t.image);
  }
}

void ScopeExternal(EMethod method) #ScopeExternalNode :
{
  Token t;
}
{
  (
  < Require > < Scope > t = < Identifier > < SemiColon >
  )
  {
    jjtThis.init(method, t.image);
  }
}

void ClauseOrStatement(EMethod method) #void :
{
}
{
  (
    ForLoop(method)
  | IfClause(method)
  | FunctionClause(method)
  | WhileLoop(method)
  | DoWhileLoop(method)
  | SwitchClause(method)
  | TryClause(method)
  | WithClause(method)
  | ThrowClause(method)
  | BreakClause(method)
  | ContinueClause(method)
  | ReturnClause(method)
  | VariableDeclarationClauseWithAssignment(method)
  | Statement(method)
  )
}

void VariableDeclarationClause(EMethod method) #VariableDeclarationClauseNode :
{
  Token t;
}
{
  (
    < Var > t = < Identifier > < SemiColon >
  )
  {
    jjtThis.init(method, t.image);
  }
}

void VariableDeclarationClauseWithAssignment(EMethod method) #VariableDeclarationClauseNode :
{
  Token t;
}
{
  (
    < Var > t = < Identifier > [ < Equal > Expression(null) ] < SemiColon >
  )
  {
    jjtThis.init(method, t.image);
  }
}

void VariableDeclarationExpressionWithAssignment(EMethod method) #VariableDeclarationClauseNode :
{
  Token t;
}
{
  (
    < Var > t = < Identifier > [ < Equal > Expression(null) ]
  )
  {
    jjtThis.init(method, t.image);
  }
}
void FunctionClause(EMethod method) #FunctionClauseNode :
{
  Token t;
  
}
{
  (
    < Function > VariableWithOptionalScope(null) < ParenOpen >
    (
      [ IdentifierName(null) ]
      (
        < Comma > IdentifierName(null)
      )*
    )
    < ParenClose >
    (
      Block(null)
    )
  )
  {
    jjtThis.init(method);
    
  }
}

void WithClause(EMethod method) #WithClauseNode :
{
  
}
{
  (
    < With > < ParenOpen > IdentifierName(null)
    (
      < Comma > IdentifierName(null)
    )*
    < ParenClose > BlockOrClause(null)
  )
  {
    jjtThis.init(method);
    
  }
}

void ContinueClause(EMethod method) #ContinueClauseNode :
{
  Token t = null;
}
{
  (
  < Continue > [ t = < Identifier > ] < SemiColon >
  )
  {
    jjtThis.init(method, t == null ? null : t.image);
    
  }
}

void BreakClause(EMethod method) #BreakClauseNode :
{
  Token t = null;
  
}
{
  (
  < Break > [ t = < Identifier > ] < SemiColon >
  )
  {
    jjtThis.init(method, t == null ? null : t.image);
    
  }
}

void ReturnClause(EMethod method) #ReturnClauseNode :
{
  
}
{
  (
    < Return > [ Expression(null) ] < SemiColon >
  )
  {
    jjtThis.init(method);
    
  }
}

void ThrowClause(EMethod method) #ThrowClauseNode :
{
  
}
{
  (
    < Throw > Expression(null) < SemiColon >
  )
  {
    jjtThis.init(method);
    
  }
}

void SwitchClause(EMethod method) #SwitchClauseNode :
{
  Token label = null;
  
}
{
  (
    < Switch > [< AngleOpen > label = < Identifier > < AngleClose >] < ParenOpen > Expression(null) < ParenClose > < BracesOpen >
    (
      SwitchCase()
    )*
    [ 
    SwitchDefault() 
    ] 
    < BracesClose >
  )
  {
    jjtThis.init(method, label != null ? label.image : null);
    
  }
}

void SwitchCase() #void :
{
}
{
  (
    (
      < Case > Expression(EMethod.SWITCHCASE) < Colon >
    )+
    (
      ClauseOrStatement(EMethod.SWITCHCLAUSE)
    )+
  )
}

void SwitchDefault() #void :
{
}
{
  (
    < Default > < Colon >
    (
      ClauseOrStatement(EMethod.SWITCHDEFAULT)
    )+
  )
}

void TryClause(EMethod method) #TryClauseNode :
{
  Token t;
}
{
  (
    < Try >
    (
      Block(null)
    )
    < Catch > < ParenOpen > t = < Identifier > < ParenClose >
    (
      Block(null)
    )
  )
  {
    jjtThis.init(method, t.image);
    
  }
}

void DoWhileLoop(EMethod method) #DoWhileLoopNode :
{
  Token label = null;
  
}
{
  (
    < Do > [< AngleOpen > label = < Identifier > < AngleClose >]
    BlockOrClause(null) 
    < While > < ParenOpen > Expression(null) < ParenClose > < SemiColon >
  )
  {
    jjtThis.init(method, label != null ? label.image : null);
  }
}

void WhileLoop(EMethod method) #WhileLoopNode :
{
  Token label = null;
  
}
{
  (
    < While > [< AngleOpen > label = < Identifier > < AngleClose >] < ParenOpen > Expression(null) < ParenClose > 
    BlockOrClause(null)
  )
  {
    jjtThis.init(method, label != null ? label.image : null);
    
  }
}

void ForLoop(EMethod method) #ForLoopNode :
{
  Token label = null;
  Token iteratingLoopVariable = null;
}
{
  (
    < For > [ < AngleOpen > label = < Identifier > < AngleClose > ] < ParenOpen >
    (
      LOOKAHEAD(< Identifier > < Colon >)
      (
        iteratingLoopVariable = < Identifier > < Colon > Expression(null)
      )
    |
      (
        ExpressionOrVariableDeclarationListCommaSeparated(null) < SemiColon > ExpressionListCommaSeparated(null) < SemiColon > ExpressionListCommaSeparated(null)
      )
    )
    < ParenClose > 
    BlockOrClause(null)
  )
  {
    jjtThis.init(method, iteratingLoopVariable != null ? iteratingLoopVariable.image : null, label != null ? label.image : null);
    
  }
}

void IfClause(EMethod method) #IfClauseNode :
{
  
}
{
  (
    < If > 
    < ParenOpen > Expression(null) < ParenClose > 
    BlockOrClause(null)
    [
      LOOKAHEAD(1)
      < Else > 
      BlockOrClause(null)
    ]
  )
  {
    jjtThis.init(method);
    
  }
}

void BlockOrClause(EMethod method) #void :
{
}
{
  LOOKAHEAD(< BracesOpen >)
  Block(method)
| ClauseOrStatement(method)
}

void Block(EMethod method) #StatementListNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    < BracesOpen >
    (
      (
        ClauseOrStatement(null)
      | LosBody(null)
      )*
    )
    < BracesClose >
  )
  {
    if (createNode) {
      jjtThis.init(method);
      
    }
  }
}

void ExpressionOrVariableDeclarationListCommaSeparated(EMethod method) #StatementListNode :
{
  
}
{
  (
    [
      (
        VariableDeclarationExpressionWithAssignment(null)
      | Expression(null)
      )
      (
        < Comma >
        (
          Expression(null)
        | VariableDeclarationExpressionWithAssignment(null)
        )
      )*
    ]
  )
  {
    jjtThis.init(method);
    
  }
}


void ExpressionListCommaSeparated(EMethod method) #StatementListNode :
{
  
}
{
  (
    [
      Expression(null)
      (
        < Comma > Expression(null)
      )*
    ]
  )
  {
    jjtThis.init(method);
    
  }
}

void Statement(EMethod method) #StatementListNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    (
      (Expression(method) (< SemiColon > | LosBody(null)))
    )
  | EmptyStatement(method)
  )
  {
    if (createNode) { 
      jjtThis.init(method);
      
    }
  }
}

Node EmptyStatement(EMethod method) #EmptyNode :
{
  
}
{
  (
  < SemiColon >
  )
  {
    jjtThis.init(method);
    
    return jjtThis;
  }
}

void Expression(EMethod method) #void :
{
}
{
  EqualTypeExpression(method)
}

void EqualTypeExpression(EMethod method) #AssignmentExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    TernaryExpression(method)
    (
      (
        < Equal >
        TernaryExpression(EMethod.EQUAL)
      )
    |
      (
        < PlusEqual > TernaryExpression(EMethod.PLUS_EQUAL)
      )
    |
      (
        < DashEqual > TernaryExpression(EMethod.DASH_EQUAL)
      )
    |
      (
        < DoubleStarEqual > TernaryExpression(EMethod.DOUBLE_STAR_EQUAL)
      )
    |
      (
        < StarEqual > TernaryExpression(EMethod.STAR_EQUAL)
      )
    |
      (
        < SlashEqual > TernaryExpression(EMethod.SLASH_EQUAL)
      )
    |
      (
        < PercentEqual > TernaryExpression(EMethod.PERCENT_EQUAL)
      )
    |
      (
        < DoubleAngleOpenEqual > TernaryExpression(EMethod.DOUBLE_ANGLE_OPEN_EQUAL)
      )
    |
      (
        < DoubleAngleCloseEqual > TernaryExpression(EMethod.DOUBLE_ANGLE_CLOSE_EQUAL)
      )
    |
      (
        < TripleAngleOpenEqual > TernaryExpression(EMethod.TRIPLE_ANGLE_OPEN_EQUAL)
      )
    |
      (
        < TripleAngleCloseEqual > TernaryExpression(EMethod.TRIPLE_ANGLE_CLOSE_EQUAL)
      )
    |
      (
        < DoubleAmpersandEqual > TernaryExpression(EMethod.DOUBLE_AMPERSAND_EQUAL)
      )
    |
      (
        < DoubleBarEqual > TernaryExpression(EMethod.DOUBLE_BAR_EQUAL)
      )
    |
      (
        < AmpersandEqual > TernaryExpression(EMethod.AMPERSAND_EQUAL)
      )
    |
      (
        < CircumflexEqual > TernaryExpression(EMethod.CIRCUMFLEX_EQUAL)
      )
    |
      (
        < BarEqual > TernaryExpression(EMethod.BAR_EQUAL)
      )
    )*
  )
  {
    
    if (createNode) jjtThis.init(method);
  }
}

void TernaryExpression(EMethod method) #TernaryExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    DoubleBarExpression(method) [
      < QuestionMark > DoubleBarExpression(method) < Colon > DoubleBarExpression(method)
    ]
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void DoubleBarExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    DoubleAmpersandExpression(method)
    (
      < DoubleBar >
      DoubleAmpersandExpression(EMethod.DOUBLE_BAR)
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void DoubleAmpersandExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    BarExpression(method)
    (
      < DoubleAmpersand >
      BarExpression(EMethod.DOUBLE_AMPERSAND)
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void BarExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    CircumflexExpression(method)
    (
      < Bar >
      CircumflexExpression(EMethod.BAR)
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void CircumflexExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    AmpersandExpression(method)
    (
      < Circumflex >
      AmpersandExpression(EMethod.CIRCUMFLEX)
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void AmpersandExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    DoubleEqualTypeExpression(method)
    (
      < Ampersand >
      DoubleEqualTypeExpression(EMethod.AMPERSAND)
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void DoubleEqualTypeExpression(EMethod method) #EqualExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    AngleTypeExpression(method)
    (
      (
        < ExclamationTilde >
        AngleTypeExpression(EMethod.EXCLAMATION_TILDE)
      )
    |
      (
        < EqualTilde >
        AngleTypeExpression(EMethod.EQUAL_TILDE)
      )
    |
      (
        < TripleEqual >
        AngleTypeExpression(EMethod.TRIPLE_EQUAL)
      )
    |
      (
        < DoubleEqual >
        AngleTypeExpression(EMethod.DOUBLE_EQUAL)
      )
    |
      (
        < ExclamationDoubleEqual >
        AngleTypeExpression(EMethod.EXCLAMATION_DOUBLE_EQUAL)
      )
    |
      (
        < ExclamationEqual >
        AngleTypeExpression(EMethod.EXCLAMATION_EQUAL)
      )
    )*
  )
  {
    if (createNode) {
      
      jjtThis.init(method);
    }
  }
}

void AngleTypeExpression(EMethod method) #ComparisonExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    MultiAngleExpression(method)
    (
      (
        < AngleOpen > MultiAngleExpression(EMethod.ANGLE_OPEN)
      )
    |
      (
        < AngleClose > MultiAngleExpression(EMethod.ANGLE_CLOSE)
      )
    |
      (
        < AngleOpenEqual > MultiAngleExpression(EMethod.ANGLE_OPEN_EQUAL)
      )
    |
      (
        < AngleCloseEqual > MultiAngleExpression(EMethod.ANGLE_CLOSE_EQUAL)
      )
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void MultiAngleExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    PlusLikeExpression(method)
    (
      (
        < DoubleAngleOpen >
        PlusLikeExpression(EMethod.DOUBLE_ANGLE_OPEN)
      )
    |
      (
        < DoubleAngleClose > 
        PlusLikeExpression(EMethod.DOUBLE_ANGLE_CLOSE)
      )
    |
      (
        < TripleAngleOpen > 
        PlusLikeExpression(EMethod.TRIPLE_ANGLE_OPEN)
      )
    |
      (
        < TripleAngleClose > 
        PlusLikeExpression(EMethod.TRIPLE_ANGLE_CLOSE)
      )
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void PlusLikeExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    StarLikeExpression(method)
    (
      (
        < Plus >
        StarLikeExpression(EMethod.PLUS)
      )
    |
      (
        < Dash > StarLikeExpression(EMethod.DASH)
      )
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void StarLikeExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  DoubleStarExpression(method)
  (
    (
      (
        < Star >
        DoubleStarExpression(EMethod.STAR)
      )
    |
      (
        < Slash > DoubleStarExpression(EMethod.SLASH)
      )
    |
      (
        < Percent > DoubleStarExpression(EMethod.PERCENT)
      )
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void DoubleStarExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    UnaryExpression(method) 
    [ 
    < DoubleStar >
    DoubleStarExpression(EMethod.DOUBLE_STAR) 
    ]
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void UnaryExpression(EMethod method) #UnaryExpressionNode(unaryMethod != null) :
{
  EMethod unaryMethod = null;
  
}
{
  (
    (
      < DoublePlus >
      UnaryExpression(method)
      {
        unaryMethod = EMethod.DOUBLE_PLUS_PREFIX;
      }
    )
  |
    (
      < DoubleDash > UnaryExpression(method)
      {
        unaryMethod = EMethod.DOUBLE_DASH_PREFIX;
      }
    )
  |
    (
      < Plus > UnaryExpression(method)
      {
        unaryMethod = EMethod.PLUS_UNARY;
      }
    )
  |
    (
      < Dash > UnaryExpression(method)
      {
        unaryMethod = EMethod.DASH_UNARY;
      }
    )
  |
    (
      < Tilde > UnaryExpression(method)
      {
        unaryMethod = EMethod.TILDE;
      }
    )
  |
    (
      < Exclamation > UnaryExpression(method)
      {
        unaryMethod = EMethod.EXCLAMATION;
      }
    )
  | 
    PostUnaryExpression(method)
  )
  {
    if (unaryMethod != null) {
      
      jjtThis.init(method, unaryMethod);
    }
  }
}

void PostUnaryExpression(EMethod method) #PostUnaryExpressionNode(unaryMethod != null) :
{
  EMethod unaryMethod = null;
  
}
{
  (
     PropertyExpression(method)
    [
      < DoublePlus > {  unaryMethod = EMethod.DOUBLE_PLUS_SUFFIX; }
    | 
      < DoubleDash > {  unaryMethod = EMethod.DOUBLE_DASH_SUFFIX; }
    ]
  )
  {
    if (unaryMethod != null) { 
      
      jjtThis.init(method, unaryMethod);
    }
  }
}

void PropertyExpression(EMethod method) #PropertyExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode = true;
}
{
  (
    FunctionTypeUnaryExpression(method)
    (
      < Dot >
      IdentifierNameAfterDot(EMethod.DOT)
    | < BracketOpen > Expression(EMethod.BRACKET) < BracketClose >
    | < ParenOpen > FunctionArgumentList(EMethod.PARENTHESIS) < ParenClose >
    )*
  )
  {
    if (createNode) {
      
      jjtThis.init(method);
    }
  }
}

void IdentifierNameAfterDot(EMethod method) #IdentifierNameNode :
{
  Token t;
  
}
{
  (
    t = < IdentifierAfterDot >
  )
  {
    jjtThis.init(method, t.image);
    
  }
}


void IdentifierName(EMethod method) #IdentifierNameNode :
{
  Token t;
  
}
{
  (
    t = < Identifier >
  )
  {
    jjtThis.init(method, t.image);
    
  }
}

void FunctionArgumentList(EMethod method) #ArrayNode :
{
  
}
{
  (
    [ Expression(null) ]
    (
      < Comma > Expression(null)
    )*
  )
  {
    jjtThis.init(method);
    
  }
}

void FunctionTypeUnaryExpression(EMethod method) #ParenthesisExpressionNode(createNode) :
{
  boolean createNode = false;
  
}
{
  (
    (
      Literal(method)
    | 
      VariableWithOptionalScope(method)
    |
      (
        < ParenOpen > Expression(null) < ParenClose > { createNode = true; }
      )
    )
  )
  {
    if (createNode) { 
      
      jjtThis.init(method);
    }
  }
}


void VariableWithOptionalScope(EMethod method) #VariableNode :
{
  Token part1;
  Token part2 = null;
  
}
{
  (
  part1 = < Identifier > [ < ScopeSeparator > part2 = < Identifier > ]
  )
  {
    if (part2 == null) 
    jjtThis.init(method, null, part1.image);
    else 
    jjtThis.init(method, part1.image, part2.image);
    
  }
}

void Number(EMethod method) #NumberNode :
{
  Token t;
  boolean isInt;
  
}
{
  (
    t = < Integer >
    {
      isInt = true;
    }
  | 
    t = < Float >
    {
      isInt = false;
    }
  )
  {
    
    jjtThis.init(method, t.image, isInt);
  }
}

void String(EMethod method) #StringNode :
{
  Token t;
  char delimiter;
  
}
{
  (
    t = < SingleQuotedString >
    {
      delimiter = '\'';
    }
  | 
    t = < DoubleQuotedString >
    {
      delimiter = '"';
    }
  )
  {
    
    jjtThis.init(method, t.image, delimiter);
  }
}

void Array(EMethod method) #ArrayNode :
{
  
}
{
  (
    < BracketOpen >
    (
      < BracketClose >
    |
      (
        Expression(null)
        (
          < Comma > Expression(null)
        )*
        < BracketClose >
      )
    )
  )
  {
    jjtThis.init(method);
    
  }
}

void Hash(EMethod method) #HashNode :
{
  
}
{
  (
    < BracesOpen >
    (
      < BracesClose >
    |
      (
        HashEntry(null)
        (
          < Comma > HashEntry(null)
        )*
        < BracesClose >
      )
    )
  )
  {
    jjtThis.init(method);
    
  }
}

void HashEntry(EMethod method) #void :
{
}
{
  (
      Literal(null)
    |
      IdentifierName(null)
  )
  < Colon > Expression(null)
}

void Null(EMethod method) #NullNode :
{
  
}
{
  < Null >
  {
    {
      jjtThis.init(method);
      
    }
  }
}

void Boolean(EMethod method) #BooleanNode :
{
  boolean b;
  
}
{
  (
    < True >
    {
      b = true;
    }
  | 
    < False >
    {
      b = false;
    }
  )
  {
    jjtThis.init(method, b);
    
  }
}

void Log(EMethod method) #LogNode :
{
  ELogLevel logLevel;
  
}
{
  (
    (
      < LogInfo >
      {
        logLevel = ELogLevel.INFO;
      }
    | < LogError >
      {
        logLevel = ELogLevel.ERROR;
      }
    | < LogDebug >
      {
        logLevel = ELogLevel.DEBUG;
      }
    | < LogWarn >
      {
        logLevel = ELogLevel.WARN;
      }
    )
    < ParenOpen > Expression(null) < ParenClose >
  )
  {
    jjtThis.init(method, logLevel);
    
  }
}

void Exception(EMethod method) #ExceptionNode :
{
  
}
{
  (
    < __Error > < ParenOpen > Expression(null) < ParenClose >
  )
  {
    jjtThis.init(method);
    
  }
}

void Function(EMethod method) #FunctionNode :
{
}
{
  (
    < LambdaArrow >
    < ParenOpen >
    (
      [ IdentifierName(null) ]
      (
        < Comma > IdentifierName(null)
      )*
    )
    < ParenClose > 
    Block(null)
  )
  {
    jjtThis.init(method);
  }
}

// i Pattern.CASE_INSENSITIVE
// m Pattern.MULTILINE
// s Pattern.DOTALL
void Regex(EMethod method) #RegexNode :
{
  Token t;
  
}
{
  (
    t = < BackslashQuotedRegex >  )
  {
    
    jjtThis.init(method, t.image);
  }
}

void Literal(EMethod method) #void :
{
}
{
  Array(method)
| Hash(method)
| String(method)
| Regex(method)
| Number(method)
| Boolean(method)
| Null(method)
| Log(method)
| Function(method)
| Exception(method)
}