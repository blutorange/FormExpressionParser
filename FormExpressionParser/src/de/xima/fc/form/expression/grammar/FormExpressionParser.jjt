options {
  BUILD_NODE_FILES = false;
  MULTI = true;
  NODE_DEFAULT_VOID = false;
  NODE_CLASS="";
  NODE_EXTENDS="";
  NODE_FACTORY="";
  NODE_PACKAGE="";
  NODE_PREFIX="AST";
  NODE_SCOPE_HOOK = false;
  NODE_USES_PARSER = true;
  TRACK_TOKENS = true;
  VISITOR = false;
  VISITOR_DATA_TYPE="Object";
  VISITOR_EXCEPTION="";
  VISITOR_RETURN_TYPE="Object";

  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER  = true;
  CACHE_TOKENS = false;
  CHOICE_AMBIGUITY_CHECK = 2;
  COMMON_TOKEN_ACTION = true;
  DEBUG_LOOKAHEAD = false;
  DEBUG_PARSER = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  FORCE_LA_CHECK = false;
  GENERATE_ANNOTATIONS = true;
  GENERATE_GENERICS = true;
  GENERATE_CHAINED_EXCEPTION = false;
  GENERATE_STRING_BUILDER = false;
  GRAMMAR_ENCODING="UTF-8";
  IGNORE_CASE  = false;
  JAVA_UNICODE_ESCAPE = false;
  JDK_VERSION="1.7";
  KEEP_LINE_COLUMN = true;
  LOOKAHEAD = 1;
  OTHER_AMBIGUITY_CHECK = 1;
  UNICODE_INPUT = true;
  USER_CHAR_STREAM = false;
  USER_TOKEN_MANAGER = false;
  SANITY_CHECK = true;
  SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
  STATIC = false;
  TOKEN_MANAGER_USES_PARSER = true;
  TOKEN_EXTENDS = "";
  TOKEN_FACTORY = "";
}
PARSER_BEGIN(FormExpressionParser)
package de.xima.fc.form.expression.grammar;
import java.lang.StringBuilder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import de.xima.fc.form.expression.impl.variable.ELangObjectClass;
import de.xima.fc.form.expression.impl.variable.VoidClass;
import de.xima.fc.form.expression.enums.EMethod;
import de.xima.fc.form.expression.enums.ELogLevel;
import de.xima.fc.form.expression.enums.EVariableTypeFlag;
import de.xima.fc.form.expression.iface.parse.IComment;
import de.xima.fc.form.expression.grammar.comment.CommentFactory;
import de.xima.fc.form.expression.util.CmnCnst;
import de.xima.fc.form.expression.util.NullUtil;
import de.xima.fc.form.expression.node.*;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import com.google.common.collect.ImmutableList;

public class FormExpressionParser
{
  private boolean _customLosAllowed = false;
  /** A list of all the comments occurring in the program. */
  @Nonnull private ImmutableList.Builder<IComment> _comments = new ImmutableList.Builder<IComment>();
  /** Current embedment context, or null when not in template mode. */
  @Nullable private String _currentEmbedmentContext;
  void setCurrentEmbedmentContext(String currentEmbedmentContext) {
    this._currentEmbedmentContext = currentEmbedmentContext;
  }
  void addComment(@Nonnull Token commentToken) {
    _comments.add(CommentFactory.fromToken(commentToken));
  }
  @Nullable public String getCurrentEmbedmentContext() {
    return _currentEmbedmentContext;
  }
  public void setLosAllowed(boolean losAllowed) {
    this._customLosAllowed = losAllowed;
  }
  @Nonnull public ImmutableList<IComment> buildComments() {
    return _comments.build();
  }
}
PARSER_END(FormExpressionParser)

/*
We use a counter and a stack to keep track of nested template literals and
inline expressions. The following example illustrates this. Consider the
following code:

  1+2;
  `Some literal words ${{foo:`${}`}}, I hope.`;

Step by step, this shows the values of the counter and step at each token:

 <beg>[]    code        (start out in mode code)
 ...
 `  0 []    ->template  (` switches to mode template)
 ...
 ${ 1 [0]   ->code      (syntax for inline expressions, switch to mode code)
 {  2 [0]   code        (in mode code, this is the syntax for a hash literal)
 ...
 `  2 [0]   ->template  (we are in mode code, so this starts another template literal)
 ${ 3 [0,2] ->code      (start another inline expression)
 }  2 [0]   ->template  (2 is on the stack, so go back to template literal)
 `  2 [0]   ->code      (we are in mode template, so this ends it)
 }  1 [0]   code        (1 is not on top of the stack, so we stay in mode code)
 }  0 []    ->template  (0 is on top of the stack, so we go back to template literal)
 ...
 `  0 []    ->code      (we are in mode template, so this ends it)
*/
TOKEN_MGR_DECLS :
{
  private int typeLevel = 0;
  private Token lastToken;
  private int countBraces = 0;
  private int[] stackTemplateLiteral = new int[4];
  private int posTemplateLiteral = -1;
  void CommonTokenAction(final Token token) {
    // Retrieve all comments, if there are any.
    lastToken = token;
    if (parser == null) return;
    Token special = token;
    if (token.specialToken != null) {
      while (special.specialToken != null) special = special.specialToken;
      while (special != null) {
        parser.addComment(special);
        special = special.next;
      }
    }
  }
  void pushTemplateLiteral() {
    if (posTemplateLiteral + 1 >= stackTemplateLiteral.length)
      stackTemplateLiteral = Arrays.copyOf(stackTemplateLiteral, 2*(posTemplateLiteral+2));
    stackTemplateLiteral[++posTemplateLiteral] = countBraces;
  }
  
  void popTemplateLiteralIfMatching() {
    if (posTemplateLiteral >= 0 && stackTemplateLiteral[posTemplateLiteral] == countBraces) {
      SwitchTo(FormExpressionParserConstants.TEMPLATE_LITERAL);
      --posTemplateLiteral;
    }
  }
}

< TYPE >
TOKEN :
{
  < TypeAngleOpen : "<" > { ++typeLevel;}
| < TypeAngleClose : ">" > { --typeLevel; if (typeLevel == 0) SwitchTo(FormExpressionParserConstants.CODE); }
| < TypeComma : "," >
| < TypeHash : "hash" >
| < TypeVar : "var" >
| < TypeTripleDot : "..." >
| < TypeVoid : "void" >
| < TypeError : "error" >
| < TypeRegex : "regex" >
| < TypeArray : "array" >
| < TypeMethod : "method" >
| < TypeString : "string" >
| < TypeNumber : "number" >
| < TypeBoolean : "boolean" >
}

< TYPE >
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

< TYPE >
SPECIAL_TOKEN:
{ 
  < TypeSingleLineComment: "//" (~["\n"])* ("\n")?>
}

< TYPE >
MORE:
{ 
  < "/*" > : TYPE_MULTI_LINE_COMMENT
}

< LOS >
TOKEN :
{
  < LosOpen : "[%" ([ "%", "$", "@", "=" ])* >
  {
    if (parser != null) parser.setCurrentEmbedmentContext(matchedToken.image);
  }
  : CODE
| 
  < LosChar : ~[ ] >
}

< TYPE_MULTI_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < TypeMultiLineComment: "*/" > : TYPE
}

< TYPE_MULTI_LINE_COMMENT >
MORE :
{
  < ~[ ] >
}


< MULTI_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < MultiLineComment: "*/" > : CODE
}

< MULTI_LINE_COMMENT >
MORE :
{
  < ~[ ] >
}

< AFTER_DOT >
TOKEN:
{
  < IdentifierAfterDot : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "_", "0"-"9" ])* > : CODE
}

< AFTER_DOT >
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

< TEMPLATE_LITERAL >
TOKEN:
{
  < TemplateLiteralInlineOpen : "${" > {
    pushTemplateLiteral();
    ++countBraces;
  } : CODE
| < TemplateLiteralClose : "`" >
  : CODE
| < TemplateLiteralChars :
    (
      ("\\" ~[ ])
    | ~[ "$", "\\", "`" ]
    )+ >
}

< CODE >
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

< CODE >
MORE:
{ 
  < "/*" > : MULTI_LINE_COMMENT
}

< CODE >
SPECIAL_TOKEN:
{ 
  < SingleLineComment: "//" (~["\n"])* ("\n")?>
}

< CODE >
TOKEN :
{
  < AngleOpen : "<" > {
    if (lastToken != null && lastToken.kind == FormExpressionParserConstants.Function) {
      typeLevel = 1;
      SwitchTo(FormExpressionParserConstants.TYPE);
    }
  }
|
  < AngleClose : ">" >
|
  < Ampersand : "&" >
|
  < QuestionMark : "?" >
|
  < Plus : "+" >
|
  < Dash : "-" >
|
  < Star : "*" >
|
  < Slash : "/" >
|
  < Circumflex : "^" >
|
  < Bar : "|" >
| 
  < Equal : "=" >
| 
  < Tilde : "~" >
| 
  < ParenOpen : "(" >
| 
  < ParenClose : ")" >
|
  < BracesOpen : "{" > {
    ++countBraces;
  }
|
  < BracesClose : "}" > {
    --countBraces;
    popTemplateLiteralIfMatching();
  }
|
  < BracketOpen : "[" >
|
  < BracketClose : "]" >
|
  < Comma : "," >
|
  < Colon : ":" >
|
  < Dot : "." > : AFTER_DOT
|
  < SemiColon : ";" >
|
  < Exclamation : "!" >
|
  < Percent : "%" >
|
  < TemplateLiteralOpen : "`"> : TEMPLATE_LITERAL
|
  < LosBodyClose : "%]" > : LOS
|
  < ScopeSeparator : "::" >
|
  < LambdaArrow : "=>" >
|
  < DoublePlus : "++" >
|
  < DoubleDash : "--" >
|
  < PlusEqual : "+=" >
|
  < DashEqual : "-=" >
|
  < TripleDot : "..." >
|
  < StarEqual : "*=" >
|
  < SlashEqual : "/=" >
|
  < PercentEqual : "%=" >
|
  < DoubleAmpersand : "&&" >
|
  < DoubleBar : "||" >
|
  < AmpersandEqual : "&=" >
|
  < AngleOpenEqual : "<=" >
|
  < AngleCloseEqual : ">=" >
|
  < BarEqual : "|=" >
|
  < CircumflexEqual : "^=" >
|
  < DoubleStar : "**" >
| 
  < DoubleEqual : "==" >
| 
  < In : "in" >
| 
  < If : "if" >
| 
  < Do : "do" >
| 
  < ExclamationEqual : "!=" >
| 
  < EqualTilde : "=~" >
|
  < ExclamationTilde : "!~" >
|
  < DoubleAngleOpen : "<<" > 
|
  < DoubleAngleClose : ">>" > 
| 
  < DoubleStarEqual : "**=" >
| 
  < DoubleAngleOpenEqual : "<<=" >
| 
  < DoubleAngleCloseEqual : ">>=" >
| 
  < TripleAngleOpenEqual : "<<<=" >
| 
  < TripleAngleCloseEqual : ">>>=" >
|
  < TripleAngleOpen : ">>>" >
|
  < TripleAngleClose : "<<<" >
| 
  < TripleEqual : "===" >
| 
  < ExclamationDoubleEqual : "!==" >
| 
  < For : "for" >
| 
  < Try : "try" >
| 
  < Var : "var" >
|
  < With : "with" >
| 
  < Else : "else" >
| 
  < Case : "case" >
|
  < True : "true" >
| 
  < Hash : "hash" > { typeLevel = 0; } : TYPE
| 
  < Void : "void" >
| 
  < Null : "null" >
| 
  < Break : "break" >
| 
  < While : "while" >
| 
  < Catch : "catch" >
| 
  < Throw : "throw" >
| 
  < Array : "array" > { typeLevel = 0; } : TYPE
| 
  < __Error : "error" >
| 
  < Scope : "scope" >
| 
  < False : "false" >
| 
  < Regex : "regex" >
| 
  < Number : "number" >
| 
  < Return : "return" >
| 
  < Method : "method" > { typeLevel = 0; } : TYPE
| 
  < Switch : "switch" >
| 
  < Global : "global" >
| 
  < String : "string" >
| 
  < Boolean : "boolean" >
| 
  < Require : "require" >
| 
  < LogInfo : "loginfo" >
| 
  < LogWarn : "logwarn" >
| 
  < Default : "default" >
| 
  < Continue : "continue" >
| 
  < Function : "function" >
| 
  < LogError : "logerror" >
| 
  < LogDebug : "logdebug" >
|
  < __Exception : "exception" >
| 
  < Identifier : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "_", "0"-"9" ])* >
| 
  < Integer : ([ "0"-"9" ])+ >
| 
  < Float :
    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< EXPONENT >)?
  | "." ([ "0"-"9" ])+ (< EXPONENT >)?
  | ([ "0"-"9" ])+ < EXPONENT > 
  >
| 
  < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >
| 
  < DoubleQuotedString :
    "\""
    (
      ("\\" ~[ ])
    | ~[ "\\", "\"" ]
    )*
    "\"" >
| 
  < SingleQuotedString :
    "'"
    (
      ("\\" ~[ ])
    | ~[ "\\", "'" ]
    )*
    "'" >
|
  < BackslashQuotedRegex :
    "#"
    (
      ("\\" ~[ ])
    | ~[ "\\", "#" ]
    )*
    "#"
    ([ "i", "m", "s" ])* >
}

Node Template(EMethod method) #StatementListNode :
{
}
{
  (
    (
      (
        LosChars(null)
        [
          LosOpen(null) TemplateProgram(null)
        ]
      )
    | 
      (        LosOpen(null) TemplateProgram(null)
      )
    )
    < EOF >
  )
  {
    if (token_source.curLexState == FormExpressionParserConstants.CODE)
      throw new ParseException(CmnCnst.Error.FINAL_CODE_BLOCK_NOT_CLOSED, token);
    jjtThis.init(method);
    
    return jjtThis;
  }
}

/* Los = Literal Output Statement */
void LosChars(EMethod method) #LosNode :
{
  Token t;
  final StringBuilder sb = new StringBuilder();
  
}
{
  (
    (
      t = < LosChar >
      {
        sb.append(t.getNonnullImage().charAt(0));
      }
    )+
  )
  {
    jjtThis.init(method, sb.toString(), null, false);
    
  }
}

void LosOpen(EMethod method) #LosNode :
{
  Token t;
  
}
{
  (
    t = < LosOpen >
  )
  {
    if (!_customLosAllowed) throw new ParseException(
      NullUtil.messageFormat(CmnCnst.Error.EMBEDDED_BLOCK_NOT_ALLOWED), token);
    jjtThis.init(method, CmnCnst.NonnullConstant.STRING_EMPTY, t.getNonnullImage(), false);    
  }
}


void LosBody(EMethod method) #LosNode :
{
  Token t = null;
  Token p = null;
  final StringBuilder sb = new StringBuilder();
  
}
{
  (
    < LosBodyClose >
    (
      t = < LosChar >
      {
        sb.append(t.getNonnullImage().charAt(0));
      }
    )*
    [ p = < LosOpen > ]
  )
  {
    if (!_customLosAllowed) throw new ParseException(
      NullUtil.messageFormat(CmnCnst.Error.EMBEDDED_BLOCK_NOT_ALLOWED), token);
    jjtThis.init(method, sb.toString(), p != null ? p.image : null, true);
  }
}

Node CompleteProgram(EMethod method) #StatementListNode :
{
}
{
  (
    (
      (
        ClauseOrStatement(null)
      | ScopeDefinition(null)
      | FunctionClauseWithOptionalScope(null)
      )+
      < EOF >
    )
  | < EOF >
  )
  {
    jjtThis.init(method);
    
    return jjtThis;
  }
}

void TemplateProgram(EMethod method) #StatementListNode :
{
}
{
  (
    (
      ClauseOrStatement(null)
    | ScopeDefinition(null)
    | FunctionClauseWithOptionalScope(null)
    | LosBody(null)
    )+
  )
  {
    jjtThis.init(method);
    
  }
}

void ScopeDefinition(EMethod method) #void :
{
}
{
  (      ScopeExternal(method)
    | ScopeGlobal(method)
    | ScopeManual(method)
  )
}

void ScopeGlobal(EMethod method) #ScopeGlobalNode :
{
}
{
  (
    < Global > < Scope > < BracesOpen >
    (
      VariableDeclarationClause(null)
    )*
    < BracesClose >
  )
  {
    jjtThis.init(method);
  }
}

void ScopeManual(EMethod method) #ScopeManualNode :
{
  Token t;
}
{
  (
    < Scope > t = < Identifier > < BracesOpen >
    (
      VariableDeclarationClause(null)
    | FunctionClause(null)
    )*
    < BracesClose >
  )
  {
    jjtThis.init(method, t.getNonnullImage());
  }
}

void ScopeExternal(EMethod method) #ScopeExternalNode :
{
  Token t;
}
{
  (
  < Require > < Scope > t = < Identifier > < SemiColon >
  )
  {
    jjtThis.init(method, t.getNonnullImage());
  }
}

void ClauseOrStatement(EMethod method) #void :
{
}
{
  (
    ForLoop(method)
  | IfClause(method)
  | WhileLoop(method)
  | DoWhileLoop(method)
  | SwitchClause(method)
  | TryClause(method)
  | WithClause(method)
  | ThrowClause(method)
  | BreakClause(method)
  | ContinueClause(method)
  | ReturnClause(method)
  | VariableDeclarationClause(method)
  | Statement(method)
  )
}

void VariableDeclarationClauseWithoutAssignment(EMethod method) #VariableDeclarationClauseNode :
{
  Token t;
}
{
  (
      VariableType(null)    
      t = < Identifier > < SemiColon >
  )
  {
    jjtThis.init(method, t.getNonnullImage());
  }
}

void VariableDeclarationClause(EMethod method) #VariableDeclarationClauseNode :
{
  Token t;
}
{
  (
      VariableType(null)    
      t = < Identifier > [ < Equal > Expression(null) ] < SemiColon >
  )
  {
    jjtThis.init(method, t.getNonnullImage());
  }
}

boolean FunctionArgument(EMethod method) #FunctionArgumentNode :
{
  Token t;
  boolean hasVarArg = false;
}
{
  (
      [ VariableType(null) ] [ <TripleDot > { hasVarArg = true; }] t = < Identifier >
  )
  {
    jjtThis.init(method, t.getNonnullImage());
    return hasVarArg;
  }
}

void VariableDeclarationExpressionWithAssignment(EMethod method) #VariableDeclarationClauseNode :
{
  Token t;
}
{
  (
      VariableType(null) t = < Identifier > [ < Equal > Expression(null) ]
  )
  {
    jjtThis.init(method, t.getNonnullImage());
  }
}

void VariableType(EMethod method) #void :
{
}
{
  (
    UnspecificVariableType(method) | SpecificVariableType(method)
  )
}

void UnspecificVariableType(EMethod method) #VariableTypeNode :
{
}
{
  (
    < Var > | < TypeVar >
  )
  {
    jjtThis.init(method, ELangObjectClass.OBJECT);
  }
}

void VoidVariableType(EMethod method) #VariableTypeNode :
{
}
{
  (
    < TypeVoid > | < Void >  )
  {
    jjtThis.init(method, VoidClass.INSTANCE);
  }
}

void SpecificVariableType(EMethod method) #VariableTypeNode :
{
  ELangObjectClass type;
  EVariableTypeFlag flag = null;
}
{
  (
    ( < Boolean >  | < TypeBoolean > )
    {
      type = ELangObjectClass.BOOLEAN;
    }
  | (< Number > | < TypeNumber >)
    {
      type = ELangObjectClass.NUMBER;
    }
  | (< String >  | < TypeString >)
    {
      type = ELangObjectClass.STRING;
    }
  |
    (
      ( < Array > | < TypeArray > )
      GenericsArray(null)
      {
        type = ELangObjectClass.ARRAY;
      }
    )
  |
    (
      ( < Hash > | < TypeHash > )
      GenericsHash(null)
      {
        type = ELangObjectClass.HASH;
      }
    )
  | ( < __Error > | < TypeError > )
    {
      type = ELangObjectClass.EXCEPTION;
    }
  | ( < Regex > | < TypeRegex > )
    {
      type = ELangObjectClass.REGEX;
    }
  |
    (
      ( < Method >  | < TypeMethod > )
      flag = GenericsMethod(null)
      {
        type = ELangObjectClass.FUNCTION;
      }
    )
  )
  {
    jjtThis.init(method, type, flag);
  }
}

void GenericsHash(EMethod method) #void:
{
}
{
  (
    < AngleOpen >
  | < TypeAngleOpen >
  )
  VariableType(method)
  (
    < Comma >
  | < TypeComma >
  )
  VariableType(method)
  (
    < AngleClose >
  | < TypeAngleClose >
  )
}

void GenericsArray(EMethod method) #void:
{
}
{
  (
    < AngleOpen >
  | < TypeAngleOpen >
  )
  VariableType(method)
  (
    < AngleClose >
  | < TypeAngleClose >
  )
}

EVariableTypeFlag GenericsMethod(EMethod method) #void:
{
  EVariableTypeFlag flag = null;
}
{
  (
    (
      < AngleOpen >
    | < TypeAngleOpen >
    )
    (
      VariableType(method)
    | VoidVariableType(method)
    )
    (
      (
        < Comma >
      | < TypeComma >
      )
      VariableType(method)
    )*
    [
      (
        < TripleDot >
      | < TypeTripleDot >
      )
      {
        flag = EVariableTypeFlag.VARARG;
      }
    ]
    (
      < AngleClose >
    | < TypeAngleClose >
    )
  )
  {
    return flag;
  }
}

void GenericsFunction(EMethod method) #void :
{
}
{
  (
    VariableType(method)
  | VoidVariableType(method)
  )
}

void FunctionClauseWithOptionalScope(EMethod method) #FunctionClauseNode :
{
  Token t;
  boolean hasVarArg = false;
  boolean hasType = false;
}
{
  (
    < Function >
    [ GenericsFunction(null) { hasType = true; } ]
    VariableWithOptionalScope(null)
    < ParenOpen >
    (
      [
        hasVarArg = FunctionArgument(null)
        (
          {
            if (hasVarArg)
              throw new ParseException(CmnCnst.Error.VAR_ARG_IN_NON_FINAL_PLACE, token);
          }
          (            < Comma > hasVarArg = FunctionArgument(null)
          )
        )*
      ]
    )
    < ParenClose >
    (
      Block(null)
    )
  )
  {
    jjtThis.init(method, hasVarArg, hasType);
  }
}

void FunctionClause(EMethod method) #FunctionClauseNode :
{
  Token t;
  boolean hasVarArg = false;
  boolean hasType = false;
}
{
  (
    < Function >
    [ GenericsFunction(null) { hasType = true; } ]
    Variable(null)
    < ParenOpen >
    (
      [
        hasVarArg = FunctionArgument(null)
        (
          {
            if (hasVarArg)
              throw new ParseException(CmnCnst.Error.VAR_ARG_IN_NON_FINAL_PLACE, token);
          }
          (
            < Comma > hasVarArg = FunctionArgument(null)
          )
        )*
      ]
    )
    < ParenClose >
    (
      Block(null)
    )
  )
  {
    jjtThis.init(method, hasVarArg, hasType);
  }
}

void WithClause(EMethod method) #WithClauseNode :
{
  
}
{
  (
    < With > < ParenOpen > IdentifierName(null)
    (
      < Comma > IdentifierName(null)
    )*
    < ParenClose > BlockOrClause(null)
  )
  {
    jjtThis.init(method);
    
  }
}

void ContinueClause(EMethod method) #ContinueClauseNode :
{
  Token t = null;
}
{
  (
  < Continue > [ t = < Identifier > ] < SemiColon >
  )
  {
    jjtThis.init(method, t == null ? null : t.getNonnullImage());
    
  }
}

void BreakClause(EMethod method) #BreakClauseNode :
{
  Token t = null;
  
}
{
  (
  < Break > [ t = < Identifier > ] < SemiColon >
  )
  {
    jjtThis.init(method, t == null ? null : t.getNonnullImage());
    
  }
}

void ReturnClause(EMethod method) #ReturnClauseNode :
{
  
}
{
  (
    < Return > [ Expression(null) ] < SemiColon >
  )
  {
    jjtThis.init(method);
    
  }
}

void ThrowClause(EMethod method) #ThrowClauseNode :
{
  
}
{
  (
    < Throw > Expression(null) < SemiColon >
  )
  {
    jjtThis.init(method);
    
  }
}

void SwitchClause(EMethod method) #SwitchClauseNode :
{
  Token label = null;
  
}
{
  (
    < Switch > [< AngleOpen > label = < Identifier > < AngleClose >] < ParenOpen > Expression(null) < ParenClose > < BracesOpen >
    (
      SwitchCase()
    )*
    [ 
    SwitchDefault() 
    ] 
    < BracesClose >
  )
  {
    jjtThis.init(method, label != null ? label.image : null);
    
  }
}

void SwitchCase() #void :
{
}
{
  (
    (
      < Case > Expression(EMethod.SWITCHCASE) < Colon >
    )+
    (
      ClauseOrStatement(EMethod.SWITCHCLAUSE)
    )+
  )
}

void SwitchDefault() #void :
{
}
{
  (
    < Default > < Colon >
    (
      ClauseOrStatement(EMethod.SWITCHDEFAULT)
    )+
  )
}

void TryClause(EMethod method) #TryClauseNode :
{
  Token t;
}
{
  (
    < Try >
    (
      Block(null)
    )
    < Catch > < ParenOpen > t = < Identifier > < ParenClose >
    (
      Block(null)
    )
  )
  {
    jjtThis.init(method, t.getNonnullImage());
    
  }
}

void DoWhileLoop(EMethod method) #DoWhileLoopNode :
{
  Token label = null;
  
}
{
  (
    < Do > [< AngleOpen > label = < Identifier > < AngleClose >]
    BlockOrClause(null) 
    < While > < ParenOpen > Expression(null) < ParenClose > < SemiColon >
  )
  {
    jjtThis.init(method, label != null ? label.image : null);
  }
}

void WhileLoop(EMethod method) #WhileLoopNode :
{
  Token label = null;
}
{
  (
    < While > [< AngleOpen > label = < Identifier > < AngleClose >] < ParenOpen > Expression(null) < ParenClose > 
    BlockOrClause(null)
  )
  {
    jjtThis.init(method, label != null ? label.image : null);
  }
}

void ForLoop(EMethod method) #ForLoopNode :
{
  Token label = null;
  Token iteratingLoopVariable = null;
  boolean hasType = false;
}
{
  (
    < For > [ < AngleOpen > label = < Identifier > < AngleClose > ] < ParenOpen >
    (
      // When we encounter the "in" keyword, we know it must
      // be an enhanced loop, as it is used only here.
      // Otherwise, it must be a plain loop.
      LOOKAHEAD([ VariableType(null) ] < Identifier > < In >)
      (
        [ VariableType(null) { hasType = true; } ]
        iteratingLoopVariable = < Identifier >
        < In >
        Expression(null)
      )
    |
      (
        ExpressionOrVariableDeclarationListCommaSeparated(null)
        < SemiColon >
        ExpressionListCommaSeparated(null)
        < SemiColon >
        ExpressionListCommaSeparated(null)
      )
    )
    < ParenClose > 
    BlockOrClause(null)
  )
  {
    jjtThis.init(method,
      iteratingLoopVariable != null ? iteratingLoopVariable.image : null,
      label != null ? label.image : null,
      hasType);
  }
}

// A dangling else binds to the closest if, which
// is what the default algorithm with a lookahead
// of 1 does.
void IfClause(EMethod method) #IfClauseNode :
{  
}
{
  (
    < If > 
    < ParenOpen > Expression(null) < ParenClose > 
    BlockOrClause(null)
    [
      LOOKAHEAD(1)
      < Else > 
      BlockOrClause(null)
    ]
  )
  {
    jjtThis.init(method);
  }
}

// An opening brace might indicate either the begining of a
// block or the beginning of a hash. In order to avoid too
// much lookahead, the parser commits to it being a block
// when it sees an opening brace. If you want a hash literal,
// put it inside a block like this:
//    if (true) {
//        { foo: "bar" };
//    }
//
void BlockOrClause(EMethod method) #void :
{
}
{
  LOOKAHEAD(< BracesOpen >)
  Block(method)
| ClauseOrStatement(method)
}

void Block(EMethod method) #StatementListNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
}
{
  (
    < BracesOpen >
    (
      (
        ClauseOrStatement(null)
      | LosBody(null)
      )*
    )
    < BracesClose >
  )
  {
    if (createNode) {
      jjtThis.init(method);
    }
  }
}

void ExpressionOrVariableDeclarationListCommaSeparated(EMethod method) #StatementListNode :
{
  
}
{
  (
    [
      (
        VariableDeclarationExpressionWithAssignment(null)
      | Expression(null)
      )
      (
        < Comma >
        (
          Expression(null)
        | VariableDeclarationExpressionWithAssignment(null)
        )
      )*
    ]
  )
  {
    jjtThis.init(method);
    
  }
}


void ExpressionListCommaSeparated(EMethod method) #StatementListNode :
{
  
}
{
  (
    [
      Expression(null)
      (
        < Comma > Expression(null)
      )*
    ]
  )
  {
    jjtThis.init(method);
    
  }
}

void Statement(EMethod method) #StatementListNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
}
{
  (
    (
      (Expression(method) (< SemiColon > | LosBody(null)))
    )
  | EmptyStatement(method)
  )
  {
    if (createNode) { 
      jjtThis.init(method);
      
    }
  }
}

Node EmptyStatement(EMethod method) #EmptyNode :
{
}
{
  (
  < SemiColon >
  )
  {
    jjtThis.init(method);
    
    return jjtThis;
  }
}

void Expression(EMethod method) #void :
{
}
{
  EqualTypeExpression(method)
}

void EqualTypeExpression(EMethod method) #AssignmentExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
}
{
  (
    TernaryExpression(method)
    (
      (
        < Equal >
        TernaryExpression(EMethod.EQUAL)
      )
    |
      (
        < PlusEqual > TernaryExpression(EMethod.PLUS_EQUAL)
      )
    |
      (
        < DashEqual > TernaryExpression(EMethod.DASH_EQUAL)
      )
    |
      (
        < DoubleStarEqual > TernaryExpression(EMethod.DOUBLE_STAR_EQUAL)
      )
    |
      (
        < StarEqual > TernaryExpression(EMethod.STAR_EQUAL)
      )
    |
      (
        < SlashEqual > TernaryExpression(EMethod.SLASH_EQUAL)
      )
    |
      (
        < PercentEqual > TernaryExpression(EMethod.PERCENT_EQUAL)
      )
    |
      (
        < DoubleAngleOpenEqual > TernaryExpression(EMethod.DOUBLE_ANGLE_OPEN_EQUAL)
      )
    |
      (
        < DoubleAngleCloseEqual > TernaryExpression(EMethod.DOUBLE_ANGLE_CLOSE_EQUAL)
      )
    |
      (
        < TripleAngleOpenEqual > TernaryExpression(EMethod.TRIPLE_ANGLE_OPEN_EQUAL)
      )
    |
      (
        < TripleAngleCloseEqual > TernaryExpression(EMethod.TRIPLE_ANGLE_CLOSE_EQUAL)
      )
    |
      (
        < AmpersandEqual > TernaryExpression(EMethod.AMPERSAND_EQUAL)
      )
    |
      (
        < CircumflexEqual > TernaryExpression(EMethod.CIRCUMFLEX_EQUAL)
      )
    |
      (
        < BarEqual > TernaryExpression(EMethod.BAR_EQUAL)
      )
    )*
  )
  {
    if (createNode) jjtThis.init(method);
  }
}

void TernaryExpression(EMethod method) #TernaryExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode; 
}
{
  (
    DoubleBarExpression(method)
    [
      < QuestionMark > DoubleBarExpression(method) < Colon > DoubleBarExpression(method)
    ]
  )
  {
    if (createNode) jjtThis.init(method);    
  }
}

void DoubleBarExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode; 
}
{
  (
    DoubleAmpersandExpression(method)
    (
      < DoubleBar >
      DoubleAmpersandExpression(EMethod.DOUBLE_BAR)
    )*
  )
  {
    if (createNode) jjtThis.init(method);   
  }
}

void DoubleAmpersandExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    BarExpression(method)
    (
      < DoubleAmpersand >
      BarExpression(EMethod.DOUBLE_AMPERSAND)
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void BarExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    CircumflexExpression(method)
    (
      < Bar >
      CircumflexExpression(EMethod.BAR)
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void CircumflexExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    AmpersandExpression(method)
    (
      < Circumflex >
      AmpersandExpression(EMethod.CIRCUMFLEX)
    )*
  )
  {
    if (createNode) jjtThis.init(method);
    
  }
}

void AmpersandExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
  
}
{
  (
    DoubleEqualTypeExpression(method)
    (
      < Ampersand >
      DoubleEqualTypeExpression(EMethod.AMPERSAND)
    )*
  )
  {
    if (createNode) jjtThis.init(method); 
  }
}

void DoubleEqualTypeExpression(EMethod method) #EqualExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
}
{
  (
    AngleTypeExpression(method)
    (
      (
        < ExclamationTilde >
        AngleTypeExpression(EMethod.EXCLAMATION_TILDE)
      )
    |
      (
        < EqualTilde >
        AngleTypeExpression(EMethod.EQUAL_TILDE)
      )
    |
      (
        < TripleEqual >
        AngleTypeExpression(EMethod.TRIPLE_EQUAL)
      )
    |
      (
        < DoubleEqual >
        AngleTypeExpression(EMethod.DOUBLE_EQUAL)
      )
    |
      (
        < ExclamationDoubleEqual >
        AngleTypeExpression(EMethod.EXCLAMATION_DOUBLE_EQUAL)
      )
    |
      (
        < ExclamationEqual >
        AngleTypeExpression(EMethod.EXCLAMATION_EQUAL)
      )
    )*
  )
  {
    if (createNode) {
      
      jjtThis.init(method);
    }
  }
}

void AngleTypeExpression(EMethod method) #ComparisonExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
}
{
  (
    MultiAngleExpression(method)
    (
      (
        < AngleOpen > MultiAngleExpression(EMethod.ANGLE_OPEN)
      )
    |
      (
        < AngleClose > MultiAngleExpression(EMethod.ANGLE_CLOSE)
      )
    |
      (
        < AngleOpenEqual > MultiAngleExpression(EMethod.ANGLE_OPEN_EQUAL)
      )
    |
      (
        < AngleCloseEqual > MultiAngleExpression(EMethod.ANGLE_CLOSE_EQUAL)
      )
    )*
  )
  {
    if (createNode) jjtThis.init(method);   
  }
}

void MultiAngleExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
}
{
  (
    PlusLikeExpression(method)
    (
      (
        < DoubleAngleOpen >
        PlusLikeExpression(EMethod.DOUBLE_ANGLE_OPEN)
      )
    |
      (
        < DoubleAngleClose > 
        PlusLikeExpression(EMethod.DOUBLE_ANGLE_CLOSE)
      )
    |
      (
        < TripleAngleOpen > 
        PlusLikeExpression(EMethod.TRIPLE_ANGLE_OPEN)
      )
    |
      (
        < TripleAngleClose > 
        PlusLikeExpression(EMethod.TRIPLE_ANGLE_CLOSE)
      )
    )*
  )
  {
    if (createNode) jjtThis.init(method);   
  }
}

void PlusLikeExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
}
{
  (
    StarLikeExpression(method)
    (
      (
        < Plus >
        StarLikeExpression(EMethod.PLUS)
      )
    |
      (
        < Dash > StarLikeExpression(EMethod.DASH)
      )
    )*
  )
  {
    if (createNode) jjtThis.init(method);
  }
}

void StarLikeExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode; 
}
{
  DoubleStarExpression(method)
  (
    (
      (
        < Star >
        DoubleStarExpression(EMethod.STAR)
      )
    |
      (
        < Slash > DoubleStarExpression(EMethod.SLASH)
      )
    |
      (
        < Percent > DoubleStarExpression(EMethod.PERCENT)
      )
    )*
  )
  {
    if (createNode) jjtThis.init(method);   
  }
}

void DoubleStarExpression(EMethod method) #ExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode;
}
{
  (
    UnaryExpression(method) 
    [ 
    < DoubleStar >
    DoubleStarExpression(EMethod.DOUBLE_STAR) 
    ]
  )
  {
    if (createNode) jjtThis.init(method);   
  }
}

void UnaryExpression(EMethod method) #UnaryExpressionNode(unaryMethod != null) :
{
  EMethod unaryMethod = null;
}
{
  (
    (
      < DoublePlus >
      UnaryExpression(method)
      {
        unaryMethod = EMethod.DOUBLE_PLUS_PREFIX;
      }
    )
  |
    (
      < DoubleDash > UnaryExpression(method)
      {
        unaryMethod = EMethod.DOUBLE_DASH_PREFIX;
      }
    )
  |
    (
      < Plus > UnaryExpression(method)
      {
        unaryMethod = EMethod.PLUS_UNARY;
      }
    )
  |
    (
      < Dash > UnaryExpression(method)
      {
        unaryMethod = EMethod.DASH_UNARY;
      }
    )
  |
    (
      < Tilde > UnaryExpression(method)
      {
        unaryMethod = EMethod.TILDE;
      }
    )
  |
    (
      < Exclamation > UnaryExpression(method)
      {
        unaryMethod = EMethod.EXCLAMATION;
      }
    )
  | 
    PostUnaryExpression(method)
  )
  {
    if (unaryMethod != null) {
      
      jjtThis.init(method, unaryMethod);
    }
  }
}

void PostUnaryExpression(EMethod method) #PostUnaryExpressionNode(unaryMethod != null) :
{
  EMethod unaryMethod = null; 
}
{
  (
     PropertyExpression(method)
    [
      < DoublePlus > {  unaryMethod = EMethod.DOUBLE_PLUS_SUFFIX; }
    | 
      < DoubleDash > {  unaryMethod = EMethod.DOUBLE_DASH_SUFFIX; }
    ]
  )
  {
    if (unaryMethod != null) { 
      
      jjtThis.init(method, unaryMethod);
    }
  }
}

void PropertyExpression(EMethod method) #PropertyExpressionNode(createNode = jjtree.nodeArity() != 1) :
{
  boolean createNode = true;
}
{
  (
    FunctionTypeUnaryExpression(method)
    (
      < Dot >
      IdentifierNameAfterDot(EMethod.DOT)
    | < BracketOpen > Expression(EMethod.BRACKET) < BracketClose >
    | < ParenOpen > FunctionArgumentList(EMethod.PARENTHESIS) < ParenClose >
    )*
  )
  {
    if (createNode) {
      
      jjtThis.init(method);
    }
  }
}

void IdentifierNameAfterDot(EMethod method) #IdentifierNameNode :
{
  Token t; 
}
{
  (
    t = < IdentifierAfterDot >
  )
  {
    jjtThis.init(method, t.getNonnullImage());    
  }
}

void IdentifierName(EMethod method) #IdentifierNameNode :
{
  Token t;
  
}
{
  (
    t = < Identifier >
  )
  {
    jjtThis.init(method, t.getNonnullImage());   
  }
}

void FunctionArgumentList(EMethod method) #ArrayNode :
{
  
}
{
  (
    [ Expression(null) ]
    (
      < Comma > Expression(null)
    )*
  )
  {
    jjtThis.init(method);
  }
}

void FunctionTypeUnaryExpression(EMethod method) #ParenthesisExpressionNode(createNode) :
{
  boolean createNode = false;
}
  // An opening parenthesis ( can be the start of a parenthesized
  // expression or the start of a lambda.
  //
  // The worst case scenario is 3 identical tokens. Thus we need
  // a lookahead of at least 4.
  //
  //   (foo) =>
  //
  // (foo) is a valid expression, only the arrow tells us it must be a lambda
{
  (
    (
      VariableWithOptionalScope(method)
    |
      LiteralWithoutFunction(method)
    |
      LOOKAHEAD(4)
      Function(method)
    |
      (
        < ParenOpen > Expression(null) < ParenClose > { createNode = true; }
      )
    )
  )
  {
    if (createNode) {
      jjtThis.init(method);
    }
  }
}

void Variable(EMethod method) #VariableNode :
{
  Token t;
}
{
  (
    t = < Identifier >
  )
  {
    jjtThis.init(method, null, t.getNonnullImage());
  }
}

void VariableWithOptionalScope(EMethod method) #VariableNode :
{
  Token part1;
  Token part2 = null;
}
{
  (
  part1 = < Identifier > [ < ScopeSeparator > part2 = < Identifier > ]
  )
  {
    if (part2 == null) 
      jjtThis.init(method, null, part1.getNonnullImage());
    else 
      jjtThis.init(method, part1.image, part2.getNonnullImage());
  }
}

void Number(EMethod method) #NumberNode :
{
  Token t;
  boolean isInt;
}
{
  (
    t = < Integer >
    {
      isInt = true;
    }
  | 
    t = < Float >
    {
      isInt = false;
    }
  )
  {
    jjtThis.init(method, t.getNonnullImage(), isInt);
  }
}

void String(EMethod method) #StringNode :
{
  char delimiter;
}
{
  (
    (
      delimiter = StringLiteral(null)
    )
  |
    (
      < TemplateLiteralOpen >
      (
        TemplateLiteralCharacters(null)
      |
        (
          < TemplateLiteralInlineOpen > [ Expression(null) ] < BracesClose >
        )
      )*
      < TemplateLiteralClose >
      {
        delimiter = '`';
      }
    )
  )
  {
    jjtThis.init(method, delimiter);
  }
}

char StringLiteral(EMethod method) #StringCharactersNode :
{
  Token t;
  char delimiter;
}
{
  (
    t = < DoubleQuotedString > { delimiter = '"'; }
  | t = < SingleQuotedString > { delimiter = '\''; }  )
  {
    String image = t.getNonnullImage();
    jjtThis.init(method, image.substring(1, image.length()-1), delimiter);
    return delimiter;
  }
}

void TemplateLiteralCharacters(EMethod method) #StringCharactersNode :
{
  Token t;
}
{
  (
    t = < TemplateLiteralChars >  )
  {
    jjtThis.init(method, t.getNonnullImage(), '`');
  }
}

void Array(EMethod method) #ArrayNode :
{
}
{
  (
    < BracketOpen >
    (
      < BracketClose >
    |
      (
        Expression(null)
        (
          < Comma > Expression(null)
        )*
        < BracketClose >
      )
    )
  )
  {
    jjtThis.init(method);
    
  }
}

void Hash(EMethod method) #HashNode :
{
  
}
{
  (
    < BracesOpen >
    (
      < BracesClose >
    |
      (
        HashEntry(null)
        (
          < Comma > HashEntry(null)
        )*
        < BracesClose >
      )
    )
  )
  {
    jjtThis.init(method);
  }
}

void HashEntry(EMethod method) #void :
{
}
{
  (
      Literal(null)
    |
      IdentifierName(null)
  )
  < Colon > Expression(null)
}

void Null(EMethod method) #NullNode :
{
}
{
  < Null >
  {
    {
      jjtThis.init(method);
    }
  }
}

void Boolean(EMethod method) #BooleanNode :
{
  boolean b; 
}
{
  (
    < True >
    {
      b = true;
    }
  | 
    < False >
    {
      b = false;
    }
  )
  {
    jjtThis.init(method, b);
  }
}

void Log(EMethod method) #LogNode :
{
  ELogLevel logLevel;
}
{
  (
    (
      < LogInfo >
      {
        logLevel = ELogLevel.INFO;
      }
    | < LogError >
      {
        logLevel = ELogLevel.ERROR;
      }
    | < LogDebug >
      {
        logLevel = ELogLevel.DEBUG;
      }
    | < LogWarn >
      {
        logLevel = ELogLevel.WARN;
      }
    )
    < ParenOpen > Expression(null) < ParenClose >
  )
  {
    jjtThis.init(method, logLevel);   
  }
}

void Exception(EMethod method) #ExceptionNode :
{
}
{
  (
    < __Exception > < ParenOpen > [ Expression(null) ] < ParenClose >
  )
  {
    jjtThis.init(method);
    
  }
}

// function foo(x, ...bar)
// function foo(x, number... bar)

void Function(EMethod method) #FunctionNode :
{
  boolean hasVarArg = false;
  boolean hasType = false;
}
{
  (
    < ParenOpen >
    (
      [
        hasVarArg = FunctionArgument(null)
        (
          {
            if (hasVarArg)
              throw new ParseException(CmnCnst.Error.VAR_ARG_IN_NON_FINAL_PLACE, token);
          }
          (
            < Comma > hasVarArg = FunctionArgument(null)
          )
        )*
      ]
    )
    < ParenClose >
    < LambdaArrow >
    [ GenericsFunction(null) { hasType = true; } ]
    Block(null)
  )
  {
    jjtThis.init(method, hasVarArg, hasType);
  }
}

// i Pattern.CASE_INSENSITIVE
// m Pattern.MULTILINE
// s Pattern.DOTALL
void Regex(EMethod method) #RegexNode :
{
  Token t;
}
{
  (
    t = < BackslashQuotedRegex >  )
  {    
    jjtThis.init(method, t.getNonnullImage());
  }
}

void Literal(EMethod method) #void :
{
}
{
  LiteralWithoutFunction(method)
| Function(method)
}

void LiteralWithoutFunction(EMethod method) #void :
{
}
{
  String(method)
| Number(method)
| Boolean(method)
| Array(method)
| Hash(method)
| Regex(method)
| Null(method)
| Log(method)
| Exception(method)
}